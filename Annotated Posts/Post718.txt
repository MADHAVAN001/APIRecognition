All	O
of	O
that	O
would	O
definitely	O
work	O
.	O
Personally	O
,	O
for	O
that	O
particular	O
problem	O
,	O
I	O
would	O
probably	O
take	O
a	O
little	O
different	O
approach	O
.	O
Maybe	O
something	O
like	O
this	O
:	O
class	B-API
MyClass	B-API
{	B-API
public	B-API
Point	B-API
point1	B-API
,	I-API
point2	B-API
,	I-API
point3	B-API
;	I-API
private	B-API
Point	B-API
[	I-API
]	I-API
points	B-API
;	I-API
public	B-API
{	B-API
//	B-API
...	I-API
this.points	B-API
=	B-API
new	B-API
Point	B-API
[	I-API
]	I-API
{	B-API
point1	I-API
,	I-API
point2	B-API
,	I-API
point3	B-API
}	I-API
;	I-API
}	B-API
public	B-API
void	B-API
{	B-API
Point	B-API
target	B-API
=	B-API
this.points	B-API
[	I-API
i+1	I-API
]	I-API
;	I-API
//	B-API
do	B-API
stuff	B-API
to	B-API
target	B-API
MyClass	B-API
(	I-API
)	I-API
(	O
int	O
i	O
)	O
When	O
using	O
patterns	O
like	O
this	O
,	O
you	O
have	O
to	O
be	O
careful	O
that	O
your	O
data	O
is	O
stored	O
by	O
reference	O
and	O
not	O
by	O
value	O
.	O
In	O
other	O
words	O
,	O
do	O
n't	O
do	O
this	O
with	O
primitives	O
.	O
You	O
have	O
to	O
use	O
their	O
big	O
bloated	O
class	O
counterparts	O
.	O
I	O
realized	O
that	O
's	O
not	O
exactly	O
the	O
question	O
,	O
but	O
the	O
question	O
has	O
been	O
pretty	O
well	O
answered	O
and	O
I	O
thought	O
maybe	O
an	O
alternative	O
approach	O
might	O
help	O
.	O

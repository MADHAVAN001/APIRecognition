Pointers	O
is	O
a	O
concept	O
t	O
at	O
for	O
many	O
can	O
be	O
confusing	O
at	O
first	O
,	O
in	O
particular	O
when	O
it	O
comes	O
to	O
copying	O
pointer	O
values	O
around	O
and	O
still	O
referencing	O
the	O
same	O
memory	O
block	O
.	O
I	O
've	O
found	O
that	O
the	O
best	O
analogy	O
is	O
to	O
consider	O
the	O
pointer	O
as	O
a	O
piece	O
of	O
paper	O
with	O
a	O
house	O
address	O
on	O
it	O
,	O
and	O
the	O
memory	O
block	O
it	O
references	O
as	O
the	O
actual	O
house	O
.	O
All	O
sorts	O
of	O
operations	O
can	O
thus	O
be	O
easily	O
explained	O
.	O
I	O
've	O
added	O
some	O
Delphi	O
code	O
down	O
below	O
,	O
and	O
some	O
comments	O
where	O
appropriate	O
.	O
I	O
chose	O
Delphi	O
since	O
my	O
other	O
main	O
programming	O
language	O
,	O
C	O
#	O
,	O
does	O
not	O
exhibit	O
things	O
like	O
memory	O
leaks	O
in	O
the	O
same	O
way	O
.	O
If	O
you	O
only	O
wish	O
to	O
learn	O
the	O
high-level	O
concept	O
of	O
pointers	O
,	O
then	O
you	O
should	O
ignore	O
the	O
parts	O
labelled	O
``	O
Memory	O
layout	O
''	O
in	O
the	O
explanation	O
below	O
.	O
They	O
are	O
intended	O
to	O
give	O
examples	O
of	O
what	O
memory	O
could	O
look	O
like	O
after	O
operations	O
,	O
but	O
they	O
are	O
more	O
low-level	O
in	O
nature	O
.	O
However	O
,	O
in	O
order	O
to	O
accurately	O
explain	O
how	O
buffer	O
overruns	O
really	O
work	O
,	O
it	O
was	O
important	O
that	O
I	O
added	O
these	O
diagrams	O
.	O
Disclaimer	O
:	O
For	O
all	O
intents	O
and	O
purposes	O
,	O
this	O
explanation	O
and	O
the	O
example	O
memory	O
layouts	O
are	O
vastly	O
simplified	O
.	O
There	O
's	O
more	O
overhead	O
and	O
a	O
lot	O
more	O
details	O
you	O
would	O
need	O
to	O
know	O
if	O
you	O
need	O
to	O
deal	O
with	O
memory	O
on	O
a	O
low-level	O
basis	O
.	O
However	O
,	O
for	O
the	O
intents	O
of	O
explaining	O
memory	O
and	O
pointers	O
,	O
it	O
is	O
accurate	O
enough	O
.	O
Let	O
's	O
assume	O
the	O
THouse	O
class	O
used	O
below	O
looks	O
like	O
this	O
:	O
type	O
THouse	O
=	O
class	O
private	O
FName	O
:	O
array	O
[	O
0..9	O
]	O
of	O
Char	O
;	O
public	O
constructor	O
Create	O
(	O
name	O
:	O
PChar	O
)	O
;	O
end	O
;	O
When	O
you	O
initialize	O
the	O
house	O
object	O
,	O
the	O
name	O
given	O
to	O
the	O
constructor	O
is	O
copied	O
into	O
the	O
private	O
field	O
FName	O
.	O
There	O
is	O
a	O
reason	O
it	O
is	O
defined	O
as	O
a	O
fixed-size	O
array	O
.	O
In	O
memory	O
,	O
there	O
will	O
be	O
some	O
overhead	O
associated	O
with	O
the	O
house	O
allocation	O
,	O
I	O
'll	O
illustrate	O
this	O
below	O
like	O
this	O
:	O
--	O
-	O
[	O
ttttNNNNNNNNNN	O
]	O
--	O
-	O
^	O
^	O
|	O
|	O
|	O
+-	O
the	O
FName	O
array	O
|	O
+-	O
overhead	O
The	O
``	O
tttt	O
''	O
area	O
is	O
overhead	O
,	O
there	O
will	O
typically	O
be	O
more	O
of	O
this	O
for	O
various	O
types	O
of	O
runtimes	O
and	O
languages	O
,	O
like	O
8	O
or	O
12	O
bytes	O
.	O
It	O
is	O
imperative	O
that	O
whatever	O
values	O
are	O
stored	O
in	O
this	O
area	O
never	O
gets	O
changed	O
by	O
anything	O
other	O
than	O
the	O
memory	O
allocator	O
or	O
the	O
core	O
system	O
routines	O
,	O
or	O
you	O
risk	O
crashing	O
the	O
program	O
.	O
Allocate	O
memory	O
Get	O
an	O
entrepreneur	O
to	O
build	O
your	O
house	O
,	O
and	O
give	O
you	O
the	O
address	O
to	O
the	O
house	O
.	O
In	O
contrast	O
to	O
the	O
real	O
world	O
,	O
memory	O
allocation	O
can	O
not	O
be	O
told	O
where	O
to	O
allocate	O
,	O
but	O
will	O
find	O
a	O
suitable	O
spot	O
with	O
enough	O
room	O
,	O
and	O
report	O
back	O
the	O
address	O
to	O
the	O
allocated	O
memory	O
.	O
In	O
other	O
words	O
,	O
the	O
entrepreneur	O
will	O
choose	O
the	O
spot	O
.	O
THouse.Create	O
(	O
'My	O
house	O
'	O
)	O
;	O
Memory	O
layout	O
:	O
--	O
-	O
[	O
ttttNNNNNNNNNN	O
]	O
--	O
-	O
1234My	O
house	O
Keep	O
a	O
variable	O
with	O
the	O
address	O
Write	O
the	O
address	O
to	O
your	O
new	O
house	O
down	O
on	O
a	O
piece	O
of	O
paper	O
.	O
This	O
paper	O
will	O
serve	O
as	O
your	O
reference	O
to	O
your	O
house	O
.	O
Without	O
this	O
piece	O
of	O
paper	O
,	O
you	O
're	O
lost	O
,	O
and	O
can	O
not	O
find	O
the	O
house	O
,	O
unless	O
you	O
're	O
already	O
in	O
it	O
.	O
var	O
h	O
:	O
THouse	O
;	O
begin	O
h	O
:	O
=	O
THouse.Create	O
(	O
'My	O
house	O
'	O
)	O
;	O
...	O
Memory	O
layout	O
:	O
h	O
v	O
--	O
-	O
[	O
ttttNNNNNNNNNN	O
]	O
--	O
-	O
1234My	O
house	O
Copy	O
pointer	O
value	O
Just	O
write	O
the	O
address	O
on	O
a	O
new	O
piece	O
of	O
paper	O
.	O
You	O
now	O
have	O
two	O
pieces	O
of	O
paper	O
that	O
will	O
get	O
you	O
to	O
the	O
same	O
house	O
,	O
not	O
two	O
separate	O
houses	O
.	O
Any	O
attempts	O
to	O
follow	O
the	O
address	O
from	O
one	O
paper	O
and	O
rearrange	O
the	O
furniture	O
at	O
that	O
house	O
will	O
make	O
it	O
seem	O
that	O
the	O
other	O
house	O
has	O
been	O
modified	O
in	O
the	O
same	O
manner	O
,	O
unless	O
you	O
can	O
explicitly	O
detect	O
that	O
it	O
's	O
actually	O
just	O
one	O
house	O
.	O
Note	O
This	O
is	O
usually	O
the	O
concept	O
that	O
I	O
have	O
the	O
most	O
problem	O
explaining	O
to	O
people	O
,	O
two	O
pointers	O
does	O
not	O
mean	O
two	O
objects	O
or	O
memory	O
blocks	O
.	O
var	O
h1	O
,	O
h2	O
:	O
THouse	O
;	O
begin	O
h1	O
:	O
=	O
THouse.Create	B
(	I
'My	I
house	I
'	I
)	I
;	O
h2	O
:	O
=	O
h1	O
;	O
//	O
copies	O
the	O
address	O
,	O
not	O
the	O
house	O
...	O
h1	O
v	O
--	O
-	O
[	O
ttttNNNNNNNNNN	O
]	O
--	O
-	O
1234My	O
house	O
^	O
h2	O
Freeing	O
the	O
memory	O
Demolish	O
the	O
house	O
.	O
You	O
can	O
then	O
later	O
on	O
reuse	O
the	O
paper	O
for	O
a	O
new	O
address	O
if	O
you	O
so	O
wish	O
,	O
or	O
clear	O
it	O
to	O
forget	O
the	O
address	O
to	O
the	O
house	O
that	O
no	O
longer	O
exists	O
.	O
var	O
h	O
:	O
THouse	O
;	O
begin	O
h	O
:	O
=	O
THouse.Create	B
(	I
'My	I
house	I
'	I
)	I
;	O
...	O
h	O
;	O
:	O
=	O
nil	O
;	O
Here	O
I	O
first	O
construct	O
the	O
house	O
,	O
and	O
get	O
hold	O
of	O
its	O
address	O
.	O
Then	O
I	O
do	O
something	O
to	O
the	O
house	O
(	O
use	O
it	O
,	O
the	O
...	O
code	O
,	O
left	O
as	O
an	O
exercise	O
for	O
the	O
reader	O
)	O
,	O
and	O
then	O
I	O
free	O
it	O
.	O
Lastly	O
I	O
clear	O
the	O
address	O
from	O
my	O
variable	O
.	O
Memory	O
layout	O
:	O
h	O
--	O
+	O
v	O
+-	O
before	O
free	O
--	O
-	O
[	O
ttttNNNNNNNNNN	O
]	O
--	O
-	O
|	O
1234My	O
house	O
--	O
+	O
h	O
(	O
now	O
points	O
nowhere	O
)	O
--	O
+	O
+-	O
after	O
free	O
--	O
--	O
--	O
--	O
--	O
--	O
--	O
--	O
--	O
--	O
--	O
|	O
(	O
note	O
,	O
memory	O
might	O
still	O
xx34My	O
house	O
--	O
+	O
contain	O
some	O
data	O
)	O
Dangling	O
pointers	O
You	O
tell	O
your	O
entrepreneur	O
to	O
destroy	O
the	O
house	O
,	O
but	O
you	O
forget	O
to	O
erase	O
the	O
address	O
from	O
your	O
piece	O
of	O
paper	O
.	O
When	O
later	O
on	O
you	O
look	O
at	O
the	O
piece	O
of	O
paper	O
,	O
you	O
've	O
forgotten	O
that	O
the	O
house	O
is	O
no	O
longer	O
there	O
,	O
and	O
goes	O
to	O
visit	O
it	O
,	O
with	O
failed	O
results	O
(	O
see	O
also	O
the	O
part	O
about	O
an	O
invalid	O
reference	O
below	O
)	O
.	O
var	O
h	O
:	O
THouse	O
;	O
begin	O
h	O
:	O
=	O
THouse.Create	B
(	I
'My	I
house	I
'	I
)	I
;	O
...	O
h.Free	O
;	O
...	O
//	O
forgot	O
to	O
clear	O
h	O
here	O
h.OpenFrontDoor	B
;	O
//	O
will	O
most	O
likely	O
fail	O
Using	O
h	O
after	O
the	O
call	O
to	O
.Free	O
might	O
work	O
,	O
but	O
that	O
is	O
just	O
pure	O
luck	O
.	O
Most	O
likely	O
it	O
will	O
fail	O
,	O
at	O
a	O
customers	O
place	O
,	O
in	O
the	O
middle	O
of	O
a	O
critical	O
operation	O
.	O
h	O
--	O
+	O
v	O
+-	O
before	O
free	O
--	O
-	O
[	O
ttttNNNNNNNNNN	O
]	O
--	O
-	O
|	O
1234My	O
house	O
--	O
+	O
h	O
--	O
+	O
v	O
+-	O
after	O
free	O
--	O
--	O
--	O
--	O
--	O
--	O
--	O
--	O
--	O
--	O
--	O
|	O
xx34My	O
house	O
--	O
+	O
As	O
you	O
can	O
see	O
,	O
h	O
still	O
points	O
to	O
the	O
remnants	O
of	O
the	O
data	O
in	O
memory	O
,	O
but	O
since	O
it	O
might	O
not	O
be	O
complete	O
,	O
using	O
it	O
as	O
before	O
might	O
fail	O
.	O
Memory	O
leak	O
You	O
lose	O
the	O
piece	O
of	O
paper	O
and	O
can	O
not	O
find	O
the	O
house	O
.	O
The	O
house	O
is	O
still	O
standing	O
somewhere	O
though	O
,	O
and	O
when	O
you	O
later	O
on	O
want	O
to	O
construct	O
a	O
new	O
house	O
,	O
you	O
can	O
not	O
reuse	O
that	O
spot	O
.	O
var	O
h	O
:	O
THouse	O
;	O
begin	O
h	O
:	O
=	O
THouse.Create	B
(	I
'My	I
house	I
'	I
)	I
;	O
h	O
:	O
=	O
THouse.Create	B
(	I
'My	I
house	I
'	I
)	I
;	O
//	O
uh-oh	O
,	O
what	O
happened	O
to	O
our	O
first	O
house	O
?	O
...	O
h.Free	O
;	O
h	O
:	O
=	O
nil	O
;	O
Here	O
we	O
overwrote	O
the	O
contents	O
of	O
the	O
h	O
variable	O
with	O
the	O
address	O
of	O
a	O
new	O
house	O
,	O
but	O
the	O
old	O
one	O
is	O
still	O
standing	O
...	O
somewhere	O
.	O
After	O
this	O
code	O
,	O
there	O
is	O
no	O
way	O
to	O
reach	O
that	O
house	O
,	O
and	O
it	O
will	O
be	O
left	O
standing	O
.	O
In	O
other	O
words	O
,	O
the	O
allocated	O
memory	O
will	O
stay	O
allocated	O
until	O
the	O
application	O
closes	O
,	O
at	O
which	O
point	O
the	O
operating	O
system	O
will	O
tear	O
it	O
down	O
.	O
Memory	O
layout	O
after	O
first	O
allocation	O
:	O
h	O
v	O
--	O
-	O
[	O
ttttNNNNNNNNNN	O
]	O
--	O
-	O
1234My	O
house	O
Memory	O
layout	O
after	O
second	O
allocation	O
:	O
h	O
v	O
--	O
-	O
[	O
ttttNNNNNNNNNN	O
]	O
--	O
-	O
[	O
ttttNNNNNNNNNN	O
]	O
1234My	O
house	O
5678My	O
house	O
A	O
more	O
common	O
way	O
to	O
get	O
this	O
method	O
is	O
just	O
to	O
forget	O
to	O
free	O
something	O
,	O
instead	O
of	O
overwriting	O
it	O
as	O
above	O
.	O
In	O
Delphi	O
terms	O
,	O
this	O
will	O
occur	O
with	O
the	O
following	O
method	O
:	O
procedure	O
OpenTheFrontDoorOfANewHouse	O
;	O
var	O
h	O
:	O
THouse	O
;	O
begin	O
h	O
:	O
=	O
THouse.Create	B
(	I
'My	I
house	I
'	I
)	I
;	O
h.OpenFrontDoor	O
;	O
//	O
uh-oh	O
,	O
no	O
.Free	O
here	O
,	O
where	O
does	O
the	O
address	O
go	O
?	O
end	O
;	O
After	O
this	O
method	O
has	O
executed	O
,	O
there	O
's	O
no	O
place	O
in	O
our	O
variables	O
that	O
the	O
address	O
to	O
the	O
house	O
exists	O
,	O
but	O
the	O
house	O
is	O
still	O
out	O
there	O
.	O
Memory	O
layout	O
:	O
h	O
--	O
+	O
v	O
+-	O
before	O
losing	O
pointer	O
--	O
-	O
[	O
ttttNNNNNNNNNN	O
]	O
--	O
-	O
|	O
1234My	O
house	O
--	O
+	O
h	O
(	O
now	O
points	O
nowhere	O
)	O
--	O
+	O
+-	O
after	O
losing	O
pointer	O
--	O
-	O
[	O
ttttNNNNNNNNNN	O
]	O
--	O
-	O
|	O
1234My	O
house	O
--	O
+	O
As	O
you	O
can	O
see	O
,	O
the	O
old	O
data	O
is	O
left	O
intact	O
in	O
memory	O
,	O
and	O
will	O
not	O
be	O
reused	O
by	O
the	O
memory	O
allocator	O
.	O
The	O
allocator	O
keeps	O
track	O
of	O
which	O
areas	O
of	O
memory	O
has	O
been	O
used	O
,	O
and	O
will	O
not	O
reuse	O
them	O
unless	O
you	O
free	O
it	O
.	O
Freeing	O
the	O
memory	O
but	O
keeping	O
a	O
(	O
now	O
invalid	O
)	O
reference	O
Demolish	O
the	O
house	O
,	O
erase	O
one	O
of	O
the	O
pieces	O
of	O
paper	O
but	O
you	O
also	O
have	O
another	O
piece	O
of	O
paper	O
with	O
the	O
old	O
address	O
on	O
it	O
,	O
when	O
you	O
go	O
to	O
the	O
address	O
,	O
you	O
wo	O
n't	O
find	O
a	O
house	O
,	O
but	O
you	O
might	O
find	O
something	O
that	O
resembles	O
the	O
ruins	O
of	O
one	O
.	O
Perhaps	O
you	O
will	O
even	O
find	O
a	O
house	O
,	O
but	O
it	O
is	O
not	O
the	O
house	O
you	O
were	O
originally	O
given	O
the	O
address	O
to	O
,	O
and	O
thus	O
any	O
attempts	O
to	O
use	O
it	O
as	O
though	O
it	O
belongs	O
to	O
you	O
might	O
fail	O
horribly	O
.	O
Sometimes	O
you	O
might	O
even	O
find	O
that	O
a	O
neighbouring	O
address	O
has	O
a	O
rather	O
big	O
house	O
set	O
up	O
on	O
it	O
that	O
occupies	O
three	O
address	O
(	O
Main	O
Street	O
1-3	O
)	O
,	O
and	O
your	O
address	O
goes	O
to	O
the	O
middle	O
of	O
the	O
house	O
.	O
Any	O
attempts	O
to	O
treat	O
that	O
part	O
of	O
the	O
large	O
3-address	O
house	O
as	O
a	O
single	O
small	O
house	O
might	O
also	O
fail	O
horribly	O
.	O
var	O
,	O
h2	O
:	O
THouse	O
;	O
begin	O
:	O
=	O
THouse.Create	B
(	I
'My	I
house	I
'	I
)	I
;	O
:	O
=	O
h1	O
;	O
//	O
copies	O
the	O
address	O
,	O
not	O
the	O
house	O
...	O
h1.Free	O
;	O
h1	O
:	O
=	O
nil	O
;	O
h2.OpenFrontDoor	O
;	O
//	O
uh-oh	O
,	O
what	O
happened	O
to	O
our	O
house	O
?	O
Here	O
the	O
house	O
was	O
torn	O
down	O
,	O
through	O
the	O
reference	O
in	O
h1	O
,	O
and	O
while	O
h1	O
was	O
cleared	O
as	O
well	O
,	O
h2	O
still	O
has	O
the	O
old	O
,	O
out-of-date	O
,	O
address	O
.	O
Access	O
to	O
the	O
house	O
that	O
is	O
no	O
longer	O
standing	O
might	O
or	O
might	O
not	O
work	O
.	O
This	O
is	O
a	O
variation	O
of	O
the	O
dangling	O
pointer	O
above	O
.	O
See	O
its	O
memory	O
layout	O
.	O
Buffer	O
overrun	O
You	O
move	O
more	O
stuff	O
into	O
the	O
house	O
than	O
you	O
can	O
possibly	O
fit	O
,	O
spilling	O
into	O
the	O
neighbours	O
house	O
or	O
yard	O
.	O
When	O
the	O
owner	O
of	O
that	O
neighbouring	O
house	O
later	O
on	O
comes	O
home	O
,	O
he	O
'll	O
find	O
all	O
sorts	O
of	O
things	O
he	O
'll	O
consider	O
his	O
own	O
.	O
This	O
is	O
the	O
reason	O
I	O
chose	O
a	O
fixed-size	O
array	O
.	O
To	O
set	O
the	O
stage	O
,	O
assume	O
that	O
the	O
second	O
house	O
we	O
allocate	O
will	O
,	O
for	O
some	O
reason	O
,	O
be	O
placed	O
before	O
the	O
first	O
one	O
in	O
memory	O
.	O
In	O
other	O
words	O
,	O
the	O
second	O
house	O
will	O
have	O
a	O
lower	O
address	O
than	O
the	O
first	O
one	O
.	O
Also	O
,	O
they	O
're	O
allocated	O
right	O
next	O
to	O
each	O
other	O
.	O
Thus	O
,	O
this	O
code	O
:	O
var	O
h1	O
,	O
h2	O
:	O
THouse	O
;	O
begin	O
h1	O
:	O
=	O
THouse.Create	B
(	I
'My	I
house	I
'	I
)	I
;	O
h2	O
:	O
=	O
THouse.Create	B
(	I
'My	I
other	I
house	I
somewhere	I
'	I
)	I
;	O
^	O
--	O
--	O
--	O
--	O
--	O
--	O
--	O
--	O
--	O
--	O
--	O
-^	O
longer	O
than	O
10	O
characters	O
0123456789	O
--	O
10	O
characters	O
Memory	O
layout	O
after	O
first	O
allocation	O
:	O
h1	O
v	O
--	O
--	O
--	O
--	O
--	O
--	O
--	O
--	O
--	O
--	O
--	O
-	O
[	O
ttttNNNNNNNNNN	O
]	O
5678My	O
house	O
Memory	O
layout	O
after	O
second	O
allocation	O
:	O
h2	O
h1	O
v	O
v	O
--	O
-	O
[	O
ttttNNNNNNNNNN	O
]	O
--	O
--	O
[	O
ttttNNNNNNNNNN	O
]	O
1234My	O
other	O
house	O
somewhereouse	O
^	O
--	O
-+	O
--	O
^	O
|	O
+-	O
overwritten	O
The	O
part	O
that	O
will	O
most	O
often	O
cause	O
crash	O
is	O
when	O
you	O
overwrite	O
important	O
parts	O
of	O
the	O
data	O
you	O
stored	O
that	O
really	O
should	O
not	O
be	O
randomly	O
changed	O
.	O
For	O
instance	O
it	O
might	O
not	O
be	O
a	O
problem	O
that	O
parts	O
of	O
the	O
name	O
of	O
the	O
h1-house	O
was	O
changed	O
,	O
in	O
terms	O
of	O
crashing	O
the	O
program	O
,	O
but	O
overwriting	O
the	O
overhead	O
of	O
the	O
object	O
will	O
most	O
likely	O
crash	O
when	O
you	O
try	O
to	O
use	O
the	O
broken	O
object	O
,	O
as	O
will	O
overwriting	O
links	O
that	O
is	O
stored	O
to	O
other	O
objects	O
in	O
the	O
object	O
.	O
Linked	O
lists	O
When	O
you	O
follow	O
an	O
address	O
on	O
a	O
piece	O
of	O
paper	O
,	O
you	O
get	O
to	O
a	O
house	O
,	O
and	O
at	O
that	O
house	O
there	O
is	O
another	O
piece	O
of	O
paper	O
with	O
a	O
new	O
address	O
on	O
it	O
,	O
for	O
the	O
next	O
house	O
in	O
the	O
chain	O
,	O
and	O
so	O
on	O
.	O
var	O
h1	O
,	O
h2	O
:	O
THouse	O
;	O
begin	O
h1	O
:	O
=	O
THouse.Create	B
(	I
'Home	I
'	I
)	I
;	O
h2	O
:	O
=	O
THouse.Create	B
(	I
'Cabin	I
'	I
)	I
;	O
h1	O
.	O
:	O
=	O
h2	O
;	O
Here	O
we	O
create	O
a	O
link	O
from	O
our	O
home	O
house	O
to	O
our	O
cabin	O
.	O
We	O
can	O
follow	O
the	O
chain	O
until	O
a	O
house	O
has	O
no	O
NextHouse	O
reference	O
,	O
which	O
means	O
it	O
's	O
the	O
last	O
one	O
.	O
To	O
visit	O
all	O
our	O
houses	O
,	O
we	O
could	O
use	O
the	O
following	O
code	O
:	O
var	O
h1	O
,	O
h2	O
:	O
THouse	O
;	O
h	O
:	O
THouse	O
;	O
begin	O
h1	O
:	O
=	O
THouse.Create	B
(	I
'Home	I
'	I
)	I
;	O
h2	O
:	O
=	O
THouse.Create	B
(	I
'Cabin	I
'	I
)	I
;	O
h1.NextHouse	O
:	O
=	O
h2	O
;	O
...	O
h	O
:	O
=	O
h1	O
;	O
while	O
h	O
nil	O
do	O
begin	O
h.LockAllDoors	O
;	O
h.CloseAllWindows	O
;	O
h	O
:	O
=	O
h.NextHouse	O
;	O
end	O
;	O
Memory	O
layout	O
(	O
added	O
NextHouse	O
as	O
a	O
link	O
in	O
the	O
object	O
,	O
noted	O
with	O
the	O
four	O
LLLL	O
's	O
in	O
the	O
below	O
diagram	O
)	O
:	O
h1	O
h2	O
v	O
v	O
--	O
-	O
[	O
ttttNNNNNNNNNNLLLL	O
]	O
--	O
--	O
[	O
ttttNNNNNNNNNNLLLL	O
]	O
1234Home	O
+	O
5678Cabin	O
+	O
|	O
^	O
|	O
+	O
--	O
--	O
--	O
--	O
+	O
*	O
(	O
no	O
link	O
)	O
In	O
basic	O
terms	O
,	O
what	O
is	O
a	O
memory	O
address	O
?	O
A	O
memory	O
address	O
is	O
in	O
basic	O
terms	O
just	O
a	O
number	O
.	O
If	O
you	O
think	O
of	O
memory	O
as	O
a	O
big	O
array	O
of	O
bytes	O
,	O
the	O
very	O
first	O
byte	O
has	O
the	O
address	O
0	O
,	O
the	O
next	O
one	O
the	O
address	O
1	O
and	O
so	O
on	O
upwards	O
.	O
This	O
is	O
simplified	O
,	O
but	O
good	O
enough	O
.	O
So	O
this	O
memory	O
layout	O
:	O
h1	O
h2	O
v	O
v	O
--	O
-	O
[	O
ttttNNNNNNNNNN	O
]	O
--	O
-	O
[	O
ttttNNNNNNNNNN	O
]	O
1234My	O
house	O
5678My	O
house	O
Might	O
have	O
these	O
two	O
address	O
(	O
the	O
leftmost	O
-	O
is	O
address	O
0	O
)	O
:	O
h1	O
=	O
4	O
h2	O
=	O
23	O
Which	O
means	O
that	O
our	O
linked	O
list	O
above	O
might	O
actuall	O
look	O
like	O
this	O
:	O
h1	O
(	O
=4	O
)	O
h2	O
(	O
=28	O
)	O
v	O
v	O
--	O
-	O
[	O
ttttNNNNNNNNNNLLLL	O
]	O
--	O
--	O
[	O
ttttNNNNNNNNNNLLLL	O
]	O
1234Home	O
0028	O
5678Cabin	O
0000	O
|	O
^	O
|	O
+	O
--	O
--	O
--	O
--	O
+	O
*	O
(	O
no	O
link	O
)	O
It	O
is	O
typical	O
to	O
store	O
an	O
address	O
that	O
``	O
points	O
nowhere	O
''	O
as	O
a	O
zero-address	O
.	O
In	O
basic	O
terms	O
,	O
what	O
is	O
a	O
pointer	O
?	O
A	O
pointer	O
is	O
just	O
a	O
variable	O
holding	O
a	O
memory	O
address	O
.	O
You	O
can	O
typically	O
ask	O
the	O
programming	O
language	O
to	O
give	O
you	O
its	O
number	O
,	O
but	O
most	O
programming	O
languages	O
and	O
runtimes	O
tries	O
to	O
hide	O
the	O
fact	O
that	O
there	O
is	O
a	O
number	O
beneath	O
,	O
just	O
because	O
the	O
number	O
itself	O
does	O
not	O
really	O
hold	O
any	O
meaning	O
to	O
you	O
.	O
It	O
is	O
best	O
to	O
think	O
of	O
a	O
pointer	O
as	O
a	O
black	O
box	O
,	O
ie	O
.	O
you	O
do	O
n't	O
really	O
know	O
or	O
care	O
about	O
how	O
it	O
is	O
actually	O
implemented	O
,	O
just	O
as	O
long	O
as	O
it	O
works	O
.	O

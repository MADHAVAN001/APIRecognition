One	O
possibility	O
lies	O
with	O
Win32	O
ANSI/Unicode	O
``	O
name-mangling	O
''	O
,	O
which	O
turns	O
the	O
symbol	O
into	O
either	O
or	O
.	O
There	O
are	O
three	O
possibilities	O
:	O
Windows.h	O
has	O
n't	O
been	O
loaded	O
,	O
so	O
stays	O
Windows.h	O
was	O
loaded	O
with	O
symbols	O
set	O
for	O
ANSI	O
,	O
so	O
becomes	O
Windows.h	O
was	O
loaded	O
with	O
symbols	O
set	O
for	O
Unicode	O
,	O
so	O
becomes	O
If	O
you	O
've	O
compiled	O
two	O
different	O
files	O
in	O
ways	O
that	O
trigger	O
two	O
different	O
scenarios	O
,	O
you	O
'll	O
get	O
a	O
linker	O
error	O
.	O
The	O
error	O
message	O
indicates	O
that	O
the	O
class	O
was	O
an	O
instance	O
of	O
#	O
2	O
,	O
above	O
--	O
perhaps	O
it	O
's	O
used	O
somewhere	O
that	O
windows.h	O
has	O
n't	O
been	O
loaded	O
?	O
Other	O
things	O
I	O
'd	O
do	O
in	O
your	O
place	O
,	O
just	O
as	O
a	O
matter	O
of	O
routine	O
:	O
1	O
)	O
Ensure	O
that	O
my	O
include	O
and	O
library	O
paths	O
do	O
n't	O
contain	O
anything	O
that	O
I	O
'm	O
not	O
expecting	O
.	O
2	O
)	O
Do	O
a	O
``	O
build	O
clean	O
''	O
and	O
then	O
manually	O
verify	O
it	O
,	O
deleting	O
any	O
extra	O
object	O
files	O
if	O
necessary	O
.	O
3	O
)	O
Make	O
sure	O
there	O
are	O
n't	O
any	O
hardcoded	O
paths	O
in	O
include	O
statements	O
that	O
do	O
n't	O
mean	O
what	O
they	O
meant	O
when	O
the	O
project	O
was	O
originally	O
rebuilt	O
.	O
EDIT	O
:	O
Fighting	O
with	O
the	O
formatting	O
:	O
(	O

This	O
should	O
work	O
reasonably	O
well	O
:	O
public	O
static	B-API
class	O
HumanFriendlyInteger	O
{	O
static	O
string	B-API
[	I-API
]	I-API
ones	O
=	O
new	O
string	B-API
[	I-API
]	I-API
{	O
``	O
''	O
,	O
``	O
One	O
''	O
,	O
``	O
Two	O
''	O
,	O
``	O
Three	O
''	O
,	O
``	O
Four	O
''	O
,	O
``	O
Five	O
''	O
,	O
``	O
Six	O
''	O
,	O
``	O
Seven	O
''	O
,	O
``	O
Eight	O
''	O
,	O
``	O
Nine	O
''	O
}	O
;	O
static	B-API
string	I-API
[	I-API
]	I-API
teens	O
=	O
new	O
string	B-API
[	I-API
]	I-API
{	O
``	O
Ten	O
''	O
,	O
``	O
Eleven	O
''	O
,	O
``	O
Twelve	O
''	O
,	O
``	O
Thirteen	O
''	O
,	O
``	O
Fourteen	O
''	O
,	O
``	O
Fifteen	O
''	O
,	O
``	O
Sixteen	O
''	O
,	O
``	O
Seventeen	O
''	O
,	O
``	O
Eighteen	O
''	O
,	O
``	O
Nineteen	O
''	O
}	O
;	O
static	B-API
string	I-API
[	I-API
]	I-API
tens	O
=	O
new	O
string	B-API
[	I-API
]	I-API
{	O
``	O
Twenty	O
''	O
,	O
``	O
Thirty	O
''	O
,	O
``	O
Forty	O
''	O
,	O
``	O
Fifty	O
''	O
,	O
``	O
Sixty	O
''	O
,	O
``	O
Seventy	O
''	O
,	O
``	O
Eighty	O
''	O
,	O
``	O
Ninety	O
''	O
}	O
;	O
static	B-API
string	I-API
[	I-API
]	I-API
thousandsGroups	O
=	O
{	O
``	O
''	O
,	O
``	O
Thousand	O
''	O
,	O
``	O
Million	O
''	O
,	O
``	O
Billion	O
''	O
}	O
;	O
private	O
static	B-API
string	I-API
FriendlyInteger	B-API
(	I-API
int	I-API
n	I-API
,	I-API
string	I-API
leftDigits	I-API
,	I-API
int	I-API
thousands	I-API
)	I-API
{	O
if	B-API
(	I-API
n	I-API
==	I-API
0	I-API
)	I-API
{	O
return	O
leftDigits	O
;	O
}	O
string	O
friendlyInt	O
=	O
leftDigits	O
;	O
if	O
(	O
friendlyInt.Length	B-API
0	O
)	O
{	O
friendlyInt	O
+=	O
``	O
``	O
;	O
}	O
if	B-API
(	I-API
n	I-API
10	I-API
)	I-API
{	O
friendlyInt	O
+=	O
ones	O
[	O
n	O
]	O
;	O
}	O
else	B-API
if	I-API
(	I-API
n	I-API
20	I-API
)	I-API
{	O
friendlyInt	O
+=	O
teens	O
[	O
n	O
-	O
10	O
]	O
;	O
}	O
else	B-API
if	I-API
(	I-API
n	I-API
100	I-API
)	I-API
{	O
friendlyInt	O
+=	O
FriendlyInteger	O
(	O
n	O
%	O
10	O
,	O
tens	O
[	O
n	O
/	O
10	O
-	O
2	O
]	O
,	O
0	O
)	O
;	O
}	O
else	B-API
if	I-API
(	I-API
n	I-API
1000	I-API
)	I-API
{	O
friendlyInt	O
+=	O
FriendlyInteger	O
(	O
n	O
%	O
100	O
,	O
(	O
ones	O
[	O
n	O
/	O
100	O
]	O
+	O
``	O
Hundred	O
''	O
)	O
,	O
0	O
)	O
;	O
}	O
else	O
{	O
friendlyInt	O
+=	O
FriendlyInteger	O
(	O
n	O
%	O
1000	O
,	O
FriendlyInteger	O
(	O
n	O
/	O
1000	O
,	O
``	O
''	O
,	O
thousands+1	O
)	O
,	O
0	O
)	O
;	O
}	O
return	O
friendlyInt	O
+	O
thousandsGroups	O
[	O
thousands	O
]	O
;	O
}	O
public	O
static	B-API
string	I-API
IntegerToWritten	O
(	O
int	O
n	O
)	O
{	O
if	B-API
(	I-API
n	I-API
==	I-API
0	I-API
)	I-API
{	O
return	O
``	O
Zero	O
''	O
;	O
}	O
else	B-API
if	I-API
(	I-API
n	I-API
0	I-API
)	I-API
{	O
return	O
``	O
Negative	O
``	O
+	O
IntegerToWritten	O
(	O
-n	O
)	O
;	O
}	O
return	O
FriendlyInteger	O
(	O
n	O
,	O
``	O
''	O
,	O
0	O
)	O
;	O
}	O
}	O
(	O
Edited	O
to	O
make	O
it	O
considerably	O
more	O
concise	O
.	O
)	O

I	O
just	O
whipped	O
this	O
up	O
quick	O
in	O
Ruby	O
:	O
def	O
all	O
=	O
[	O
``	O
''	O
]	O
current_array	B-API
=	O
all.clone	B-API
{	O
|iteration|	O
next_array	O
=	O
[	O
]	O
current_array.each	B-API
{	O
|string|	O
possible_characters.each	B-API
{	O
|c|	O
value	O
=	O
string	O
+	O
c	O
next_array.insert	B-API
next_array.length	B-API
,	O
value	O
all.insert	O
all.length	O
,	O
value	O
}	O
}	O
current_array	O
=	O
next_array	O
}	O
all.delete_if	O
{	O
|string|	O
string.length	B-API
x	O
(	O
x	O
,	O
y	O
,	O
possible_characters	O
)	O
1.upto	B-API
(	I-API
y	I-API
)	I-API
You	O
might	O
look	O
into	O
language	O
API	O
for	O
built	O
in	O
permutation	O
type	O
functions	O
,	O
and	O
you	O
might	O
be	O
able	O
to	O
write	O
more	O
optimized	O
code	O
,	O
but	O
if	O
the	O
numbers	O
are	O
all	O
that	O
high	O
,	O
I	O
'm	O
not	O
sure	O
there	O
is	O
much	O
of	O
a	O
way	O
around	O
having	O
a	O
lot	O
of	O
results	O
.	O
Anyways	O
,	O
the	O
idea	O
behind	O
the	O
code	O
is	O
start	O
with	O
string	O
of	O
length	O
0	O
,	O
then	O
keep	O
track	O
of	O
all	O
the	O
strings	O
of	O
length	O
Z	O
where	O
Z	O
is	O
the	O
current	O
size	O
in	O
the	O
iteration	O
.	O
Then	O
,	O
go	O
through	O
each	O
string	O
and	O
append	O
each	O
character	O
onto	O
each	O
string	O
.	O
Finally	O
at	O
the	O
end	O
,	O
remove	O
any	O
that	O
were	O
below	O
the	O
x	O
threshold	O
and	O
return	O
the	O
result	O
.	O
I	O
did	O
n't	O
test	O
it	O
with	O
potentially	O
meaningless	O
input	O
(	O
null	O
character	O
list	O
,	O
weird	O
values	O
of	O
x	O
and	O
y	O
,	O
etc	O
)	O
.	O

I	O
just	O
whipped	O
this	O
up	O
quick	O
in	O
Ruby	O
:	O
def	B
all	B
=	B
[	B
``	I
''	I
]	I
current_array	B
=	B
all.clone	B
{	B
|iteration|	B
next_array	B
=	B
[	B
]	I
current_array.each	B
{	B
|string|	B
possible_characters.each	B
{	B
|c|	B
value	B
=	B
string	B
+	B
c	B
next_array.insert	B
next_array.length	B
,	I
value	B
all.insert	B
all.length	B
,	I
value	B
}	B
}	B
current_array	B
=	B
next_array	B
}	B
all.delete_if	B
{	B
|string|	B
string.length	B
x	B
(	O
x	O
,	O
y	O
,	O
possible_characters	O
)	O
1.upto	B
(	I
y	I
)	I
You	O
might	O
look	O
into	O
language	O
API	O
for	O
built	O
in	O
permutation	O
type	O
functions	O
,	O
and	O
you	O
might	O
be	O
able	O
to	O
write	O
more	O
optimized	O
code	O
,	O
but	O
if	O
the	O
numbers	O
are	O
all	O
that	O
high	O
,	O
I	O
'm	O
not	O
sure	O
there	O
is	O
much	O
of	O
a	O
way	O
around	O
having	O
a	O
lot	O
of	O
results	O
.	O
Anyways	O
,	O
the	O
idea	O
behind	O
the	O
code	O
is	O
start	O
with	O
string	O
of	O
length	O
0	O
,	O
then	O
keep	O
track	O
of	O
all	O
the	O
strings	O
of	O
length	O
Z	O
where	O
Z	O
is	O
the	O
current	O
size	O
in	O
the	O
iteration	O
.	O
Then	O
,	O
go	O
through	O
each	O
string	O
and	O
append	O
each	O
character	O
onto	O
each	O
string	O
.	O
Finally	O
at	O
the	O
end	O
,	O
remove	O
any	O
that	O
were	O
below	O
the	O
x	O
threshold	O
and	O
return	O
the	O
result	O
.	O
I	O
did	O
n't	O
test	O
it	O
with	O
potentially	O
meaningless	O
input	O
(	O
null	O
character	O
list	O
,	O
weird	O
values	O
of	O
x	O
and	O
y	O
,	O
etc	O
)	O
.	O

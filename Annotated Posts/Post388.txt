@	O
Bernard	O
:	O
I	O
have	O
to	O
admit	O
,	O
most	O
of	O
your	O
example	O
went	O
straight	O
over	O
my	O
head	O
.	O
It	O
does	O
compile	O
,	O
and	O
seems	O
to	O
work	O
,	O
though	O
.	O
Is	O
this	O
safe	O
for	O
SMP	O
systems	O
or	O
SpeedStep	O
?	O
That	O
's	O
a	O
good	O
question	O
...	O
I	O
think	O
the	O
code	O
's	O
ok.	O
From	O
a	O
practical	O
standpoint	O
,	O
we	O
use	O
it	O
in	O
my	O
company	O
every	O
day	O
,	O
and	O
we	O
run	O
on	O
a	O
pretty	O
wide	O
array	O
of	O
boxes	O
,	O
everything	O
from	O
2-8	O
cores	O
.	O
Of	O
course	O
,	O
YMMV	O
,	O
etc	O
,	O
but	O
it	O
seems	O
to	O
be	O
a	O
reliable	O
and	O
low-overhead	O
(	O
because	O
it	O
does	O
n't	O
make	O
a	O
context	O
switch	O
into	O
system-space	O
)	O
method	O
of	O
timing	O
.	O
Generally	O
how	O
it	O
works	O
is	O
:	O
declare	O
the	O
block	O
of	O
code	O
to	O
be	O
assembler	O
(	O
and	O
volatile	O
,	O
so	O
the	O
optimizer	O
will	O
leave	O
it	O
alone	O
)	O
.	O
execute	O
the	O
CPUID	O
instruction	O
.	O
In	O
addition	O
to	O
getting	O
some	O
CPU	O
information	O
(	O
which	O
we	O
do	O
n't	O
do	O
anything	O
with	O
)	O
it	O
synchronizes	O
the	O
CPU	O
's	O
execution	O
buffer	O
so	O
that	O
the	O
timings	O
are	O
n't	O
affected	O
by	O
out-of-order	O
execution	O
.	O
execute	O
the	O
rdtsc	B
(	I
read	I
timestamp	I
)	I
execution	O
.	O
This	O
fetches	O
the	O
number	O
of	O
machine	O
cycles	O
executed	O
since	O
the	O
processor	O
was	O
reset	O
.	O
This	O
is	O
a	O
64-bit	O
value	O
,	O
so	O
with	O
current	O
CPU	O
speeds	O
it	O
will	O
wrap	O
around	O
every	O
194	O
years	O
or	O
so	O
.	O
Interestingly	O
,	O
in	O
the	O
original	O
Pentium	O
reference	O
,	O
they	O
note	O
it	O
wraps	O
around	O
every	O
5800	O
years	O
or	O
so	O
.	O
the	O
last	O
couple	O
of	O
lines	O
store	O
the	O
values	O
from	O
the	O
registers	O
into	O
the	O
variables	O
hi	O
and	O
lo	O
,	O
and	O
put	O
that	O
into	O
the	O
64-bit	O
return	O
value	O
.	O
Specific	O
notes	O
:	O
out-of-order	O
execution	O
can	O
cause	O
incorrect	O
results	O
,	O
so	O
we	O
execute	O
the	O
''	O
cpuid	O
''	O
instruction	O
which	O
in	O
addition	O
to	O
giving	O
you	O
some	O
information	O
about	O
the	O
cpu	O
also	O
synchronizes	O
any	O
out-of-order	O
instruction	O
execution	O
.	O
Most	O
OS	O
's	O
synchronize	O
the	O
counters	O
on	O
the	O
CPUs	O
when	O
they	O
start	O
,	O
so	O
the	O
answer	O
is	O
good	O
to	O
within	O
a	O
couple	O
of	O
nano-seconds	O
.	O
The	O
hibernating	O
comment	O
is	O
probably	O
true	O
,	O
but	O
in	O
practice	O
you	O
probably	O
do	O
n't	O
care	O
about	O
timings	O
across	O
hibernation	O
boundaries	O
.	O
regarding	O
speedstep	O
:	O
Newer	O
Intel	O
CPUs	O
compensate	O
for	O
the	O
speed	O
changes	O
and	O
returns	O
an	O
adjusted	O
count	O
.	O
I	O
did	O
a	O
quick	O
scan	O
over	O
some	O
of	O
the	O
boxes	O
on	O
our	O
network	O
and	O
found	O
only	O
one	O
box	O
that	O
did	O
n't	O
have	O
it	O
:	O
a	O
Pentium	O
3	O
running	O
some	O
old	O
database	O
server	O
.	O
(	O
these	O
are	O
linux	O
boxes	O
,	O
so	O
I	O
checked	O
with	O
:	O
grep	O
constant_tsc	O
/proc/cpuinfo	O
)	O
I	O
'm	O
not	O
sure	O
about	O
the	O
AMD	O
CPUs	O
,	O
we	O
're	O
primarily	O
an	O
Intel	O
shop	O
,	O
although	O
I	O
know	O
some	O
of	O
our	O
low-level	O
systems	O
gurus	O
did	O
an	O
AMD	O
evaluation	O
.	O
Hope	O
this	O
satisfies	O
your	O
curiosity	O
,	O
it	O
's	O
an	O
interesting	O
and	O
(	O
IMHO	O
)	O
under-studied	O
area	O
of	O
programming	O
.	O
You	O
know	O
when	O
Jeff	O
and	O
Joel	O
were	O
talking	O
about	O
whether	O
or	O
not	O
a	O
programmer	O
should	O
know	O
C	O
?	O
I	O
was	O
shouting	O
at	O
them	O
,	O
``	O
hey	O
forget	O
that	O
high-level	O
C	O
stuff	O
...	O
assembler	O
is	O
what	O
you	O
should	O
learn	O
if	O
you	O
want	O
to	O
know	O
what	O
the	O
computer	O
is	O
doing	O
!	O
''	O

Another	O
interesting	O
thing	O
with	O
this	O
example	O
is	O
the	O
method	O
overloading	O
.	O
The	O
combination	O
of	O
type	O
widening	O
and	O
method	O
overloading	O
only	O
working	O
because	O
the	O
compiler	O
has	O
to	O
make	O
a	O
decision	O
of	O
which	O
method	O
to	O
choose	O
.	O
Consider	O
the	O
following	O
example	O
:	O
public	O
static	O
void	O
hello	O
(	O
Collection	O
x	O
)	O
{	O
System.out.println	B-API
(	I-API
``	I-API
Collection	I-API
''	I-API
)	I-API
;	O
}	O
public	O
static	O
void	O
hello	O
(	O
List	O
x	O
)	O
{	O
System.out.println	B-API
(	I-API
``	I-API
List	I-API
''	I-API
)	I-API
;	O
}	O
public	O
static	O
void	O
main	O
(	O
String	B-API
[	I-API
]	I-API
args	I-API
)	I-API
{	O
Collection	B-API
col	I-API
=	I-API
new	I-API
ArrayList	I-API
(	I-API
)	I-API
;	O
hello	O
(	O
col	O
)	O
;	O
}	O
It	O
does	O
n't	O
use	O
the	O
run-time	O
type	O
which	O
is	O
List	O
,	O
it	O
uses	O
the	O
compile-time	O
type	O
which	O
is	O
Collection	B-API
and	O
thus	O
prints	O
``	O
Collection	B-API
''	O
.	O
I	O
encourage	O
your	O
to	O
read	O
Effective	O
Java	O
,	O
which	O
opened	O
my	O
eyes	O
to	O
some	O
corner	O
cases	O
of	O
the	O
JLS	O
.	O
ZOiqZQIbRMC	O

I	O
'm	O
working	O
on	O
a	O
multithreaded	O
C++	O
application	O
that	O
is	O
corrupting	O
the	O
heap	O
.	O
The	O
usual	O
tools	O
to	O
locate	O
this	O
corruption	O
seem	O
to	O
be	O
inapplicable	O
.	O
Old	O
builds	O
(	O
18	O
months	O
old	O
)	O
of	O
the	O
source	O
code	O
exhibit	O
the	O
same	O
behaviour	O
as	O
the	O
most	O
recent	O
release	O
,	O
so	O
this	O
has	O
been	O
around	O
for	O
a	O
long	O
time	O
and	O
just	O
was	O
n't	O
noticed	O
;	O
on	O
the	O
downside	O
,	O
source	O
deltas	O
ca	O
n't	O
be	O
used	O
to	O
identify	O
when	O
the	O
bug	O
was	O
introduced	O
-	O
there	O
are	O
a	O
lot	O
of	O
code	O
changes	O
in	O
the	O
repository	O
.	O
The	O
prompt	O
for	O
crashing	O
behaviuor	O
is	O
to	O
generate	O
throughput	O
in	O
this	O
system	O
-	O
socket	O
transfer	O
of	O
data	O
which	O
is	O
munged	O
into	O
an	O
internal	O
representation	O
.	O
I	O
have	O
a	O
set	O
of	O
test	O
data	O
that	O
will	O
periodically	O
cause	O
the	O
app	O
to	O
exception	O
(	O
various	O
places	O
,	O
various	O
causes	O
-	O
including	O
heap	O
alloc	O
failing	O
,	O
thus	O
:	O
heap	O
corruption	O
)	O
.	O
The	O
behaviour	O
seems	O
related	O
to	O
CPU	O
power	O
or	O
memory	O
bandwidth	O
;	O
the	O
more	O
of	O
each	O
the	O
machine	O
has	O
,	O
the	O
easier	O
it	O
is	O
to	O
crash	O
.	O
Disabling	O
a	O
hyper-threading	O
core	O
or	O
a	O
dual-core	O
core	O
reduces	O
the	O
rate	O
of	O
(	O
but	O
does	O
not	O
eliminate	O
)	O
corruption	O
.	O
This	O
suggests	O
a	O
timing	O
related	O
issue	O
.	O
Now	O
here	O
's	O
the	O
rub	O
:	O
When	O
it	O
's	O
run	O
under	O
a	O
lightweight	O
debug	O
environment	O
(	O
say	O
Visual	O
Studio	O
98	O
/	O
AKA	O
)	O
the	O
heap	O
corruption	O
is	O
reasonably	O
easy	O
to	O
reproduce	O
-	O
ten	O
or	O
fifteen	O
minutes	O
pass	O
before	O
something	O
fails	O
horrendously	O
and	O
exceptions	O
,	O
like	O
an	O
when	O
running	O
under	O
a	O
sophisticated	O
debug	O
environment	O
(	O
Rational	O
Purify	O
,	O
or	O
even	O
Microsoft	O
Application	O
Verifier	O
)	O
the	O
system	O
becomes	O
memory-speed	O
bound	O
and	O
does	O
n't	O
crash	O
(	O
Memory-bound	O
:	O
CPU	O
is	O
not	O
getting	O
above	O
,	O
disk	O
light	O
is	O
not	O
on	O
,	O
the	O
program	O
's	O
going	O
as	O
fast	O
it	O
can	O
,	O
box	O
consuming	O
of	O
2G	O
of	O
RAM	O
)	O
.	O
So	O
,	O
I	O
've	O
got	O
a	O
choice	O
between	O
being	O
able	O
to	O
reproduce	O
the	O
problem	O
(	O
but	O
not	O
identify	O
the	O
cause	O
)	O
or	O
being	O
able	O
to	O
idenify	O
the	O
cause	O
or	O
a	O
problem	O
I	O
ca	O
n't	O
reproduce	O
.	O
My	O
current	O
best	O
guesses	O
as	O
to	O
where	O
to	O
next	O
is	O
:	O
Get	O
an	O
insanely	O
grunty	O
box	O
(	O
to	O
replace	O
the	O
current	O
dev	O
box	O
:	O
2Gb	O
RAM	O
in	O
an	O
E6550	B
Core2	B
)	O
;	O
this	O
will	O
make	O
it	O
possible	O
to	O
repro	O
the	O
crash	O
causing	O
mis-behaviour	O
when	O
running	O
under	O
a	O
powerful	O
debug	O
environment	O
;	O
or	O
Rewrite	O
operators	O
and	O
to	O
use	O
and	O
to	O
mark	O
memory	O
as	O
read-only	O
as	O
soon	O
as	O
it	O
's	O
done	O
with	O
.	O
Run	O
under	O
and	O
have	O
the	O
OS	O
catch	O
the	O
bad-guy	O
who	O
's	O
writing	O
to	O
freed	O
memory	O
.	O
Yes	O
,	O
this	O
is	O
a	O
sign	O
of	O
desperation	O
:	O
who	O
the	O
hell	O
rewrites	O
and	O
?	O
!	O
I	O
wonder	O
if	O
this	O
is	O
going	O
to	O
make	O
it	O
as	O
slow	O
as	O
under	O
Purify	O
et	O
al	O
.	O
And	O
,	O
no	O
:	O
Shipping	O
with	O
Purify	O
instrumentation	O
built	O
in	O
is	O
not	O
an	O
option	O
.	O
A	O
colleague	O
just	O
walked	O
past	O
and	O
asked	O
``	O
Stack	O
Overflow	O
?	O
Are	O
we	O
getting	O
stack	O
overflows	O
now	O
?	O
!	O
?	O
''	O
And	O
now	O
,	O
the	O
question	O
:	O
How	O
do	O
I	O
locate	O
the	O
heap	O
corruptor	O
?	O
Update	O
:	O
balancing	O
and	O
seems	O
to	O
have	O
gotten	O
a	O
long	O
way	O
towards	O
solving	O
the	O
problem	O
.	O
Instead	O
of	O
15mins	O
,	O
the	O
app	O
now	O
goes	O
about	O
two	O
hours	O
before	O
crashing	O
.	O
Not	O
there	O
yet	O
.	O
Any	O
further	O
suggestions	O
?	O
The	O
heap	O
corruption	O
persists	O
.	O
Update	O
:	O
a	O
release	O
build	O
under	O
Visual	O
Studio	O
2008	O
seems	O
dramatically	O
better	O
;	O
current	O
suspicion	O
rests	O
on	O
the	O
implementation	O
that	O
ships	O
with	O
.	O
Reproduce	O
the	O
problem	O
.	O
Dr	B
will	O
produce	O
a	O
dump	O
that	O
might	O
be	O
helpful	O
in	O
further	O
analysis	O
.	O
I	O
'll	O
take	O
a	O
note	O
of	O
that	O
,	O
but	O
I	O
'm	O
concerned	O
that	O
Dr	O
Watson	O
will	O
only	O
be	O
tripped	O
up	O
after	O
the	O
fact	O
,	O
not	O
when	O
the	O
heap	O
is	O
getting	O
stomped	O
on	O
.	O
Another	O
try	O
might	O
be	O
using	O
as	O
a	O
debugging	O
tool	O
which	O
is	O
quite	O
powerful	O
being	O
at	O
the	O
same	O
time	O
also	O
lightweight	O
.	O
Got	O
that	O
going	O
at	O
the	O
moment	O
,	O
again	O
:	O
not	O
much	O
help	O
until	O
something	O
goes	O
wrong	O
.	O
I	O
want	O
to	O
catch	O
the	O
vandal	O
in	O
the	O
act	O
.	O
Maybe	O
these	O
tools	O
will	O
allow	O
you	O
at	O
least	O
to	O
narrow	O
the	O
problem	O
to	O
certain	O
component	O
.	O
I	O
do	O
n't	O
hold	O
much	O
hope	O
,	O
but	O
desperate	O
times	O
call	O
for	O
...	O
And	O
are	O
you	O
sure	O
that	O
all	O
the	O
components	O
of	O
the	O
project	O
have	O
correct	O
runtime	O
library	O
settings	O
(	O
C/C++	B
,	O
Code	O
Generation	O
category	O
in	O
VS	O
6.0	O
project	O
settings	O
)	O
?	O
No	O
I	O
'm	O
not	O
,	O
and	O
I	O
'll	O
spend	O
a	O
couple	O
of	O
hours	O
tomorrow	O
going	O
through	O
the	O
workspace	O
(	O
58	O
projects	O
in	O
it	O
)	O
and	O
checking	O
they	O
're	O
all	O
compiling	O
and	O
linking	O
with	O
the	O
appropriate	O
flags	O
.	O
Update	O
:	O
This	O
took	O
30	O
seconds	O
.	O
Select	O
all	O
projects	O
in	O
the	O
dialog	O
,	O
unselect	O
until	O
you	O
find	O
the	O
project	O
(	O
s	O
)	O
that	O
do	O
n't	O
have	O
the	O
right	O
settings	O
(	O
they	O
all	O
had	O
the	O
right	O
settings	O
)	O
.	O

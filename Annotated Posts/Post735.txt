Brian	O
gives	O
a	O
nice	O
solution	O
for	O
converting	O
it	O
to	O
a	O
strongly	O
typed	O
collection	O
.	O
Most	O
of	O
the	O
CSV	O
parsing	O
methods	O
given	O
do	O
n't	O
take	O
into	O
account	O
escaping	O
fields	O
or	O
some	O
of	O
the	O
other	O
subtleties	O
of	O
CSV	O
files	O
(	O
like	O
trimming	O
fields	O
)	O
.	O
Here	O
is	O
the	O
code	O
I	O
personally	O
use	O
.	O
It	O
's	O
a	O
bit	O
rough	O
around	O
the	O
edges	O
and	O
has	O
pretty	O
much	O
no	O
error	O
reporting	O
.	O
public	B
static	B
IListIListstring	B
{	B
IListIListstring	B
records	B
=	B
new	B
;	B
StringReader	B
stringReader	B
=	B
new	B
;	B
bool	B
inQoutedString	B
=	B
false	B
;	I
IListstring	B
record	B
=	B
new	B
;	B
StringBuilder	B
fieldBuilder	B
=	B
new	B
;	B
while	B
!	B
=	I
-1	B
)	I
{	B
char	B
readChar	B
=	B
;	B
if	B
(	B
readChar	I
==	B
'\n	B
'	I
||	B
(	B
readChar	I
==	B
'\r	B
'	I
==	B
'\n	B
'	I
)	I
)	I
{	B
//	B
If	B
it	B
's	I
a	B
\r\n	B
combo	B
consume	B
the	B
\n	B
part	B
and	B
throw	B
it	B
away	B
.	I
if	B
(	B
readChar	I
==	B
'\r	B
'	I
)	I
{	B
;	B
}	B
if	B
(	B
inQoutedString	I
)	I
{	B
if	B
(	B
readChar	I
==	B
'\r	B
'	I
)	I
{	B
;	B
}	B
;	B
}	B
else	B
{	B
)	B
;	I
fieldBuilder	B
=	B
new	B
;	B
;	B
record	B
=	B
new	B
;	B
inQoutedString	B
=	B
false	B
;	I
}	B
}	B
else	B
if	B
(	B
fieldBuilder.Length	I
==	B
0	B
!	B
inQoutedString	I
)	I
{	B
if	B
)	B
{	B
//	B
Ignore	B
leading	B
whitespace	B
}	B
else	B
if	B
(	B
readChar	I
==	B
'	B
''	I
'	I
)	I
{	B
inQoutedString	B
=	B
true	B
;	I
}	B
else	B
if	B
(	B
readChar	I
==	B
'	B
,	I
'	I
)	I
{	B
)	B
;	I
fieldBuilder	B
=	B
new	B
;	B
}	B
else	B
{	B
;	B
}	B
}	B
else	B
if	B
(	B
readChar	I
==	B
'	B
,	I
'	I
)	I
{	B
if	B
(	B
inQoutedString	I
)	I
{	B
;	B
}	B
else	B
{	B
)	B
;	I
fieldBuilder	B
=	B
new	B
;	B
}	B
}	B
else	B
if	B
(	B
readChar	I
==	B
'	B
''	I
'	I
)	I
{	B
if	B
(	B
inQoutedString	I
)	I
{	B
if	B
==	B
'	B
''	I
'	I
)	I
{	B
;	B
;	B
}	B
else	B
{	B
inQoutedString	B
=	B
false	B
;	I
}	B
}	B
else	B
{	B
;	B
}	B
}	B
else	B
{	B
;	B
}	B
}	B
)	B
;	I
;	B
return	B
(	O
string	O
content	O
)	O
ListIListstring	B
(	I
)	I
StringReader	B
(	I
content	I
)	I
Liststring	B
(	I
)	I
StringBuilder	B
(	I
)	I
(	B
stringReader.Peek	I
(	I
)	I
(	B
char	I
)	I
stringReader.Read	I
(	I
)	I
stringReader.Peek	B
(	I
)	I
stringReader.Read	B
(	I
)	I
fieldBuilder.Append	B
(	I
'\r	I
'	I
)	I
fieldBuilder.Append	B
(	I
'\n	I
'	I
)	I
record.Add	B
(	I
fieldBuilder.ToString	I
(	I
)	I
.TrimEnd	I
(	I
)	I
StringBuilder	B
(	I
)	I
records.Add	B
(	I
record	I
)	I
Liststring	B
(	I
)	I
(	B
char.IsWhiteSpace	I
(	I
readChar	I
)	I
record.Add	B
(	I
fieldBuilder.ToString	I
(	I
)	I
.TrimEnd	I
(	I
)	I
StringBuilder	B
(	I
)	I
fieldBuilder.Append	B
(	I
readChar	I
)	I
fieldBuilder.Append	B
(	I
'	I
,	I
'	I
)	I
record.Add	B
(	I
fieldBuilder.ToString	I
(	I
)	I
.TrimEnd	I
(	I
)	I
StringBuilder	B
(	I
)	I
(	B
stringReader.Peek	I
(	I
)	I
stringReader.Read	B
(	I
)	I
fieldBuilder.Append	B
(	I
'	I
''	I
'	I
)	I
fieldBuilder.Append	B
(	I
readChar	I
)	I
fieldBuilder.Append	B
(	I
readChar	I
)	I
record.Add	B
(	I
fieldBuilder.ToString	I
(	I
)	I
.TrimEnd	I
(	I
)	I
records.Add	B
(	I
record	I
)	I
Note	O
that	O
this	O
does	O
n't	O
handle	O
the	O
edge	O
case	O
of	O
fields	O
not	O
being	O
deliminated	O
by	O
double	O
quotes	O
,	O
but	O
meerley	O
having	O
a	O
quoted	O
string	O
inside	O
of	O
it	O
.	O
See	O
this	O
post	O
for	O
a	O
bit	O
of	O
a	O
better	O
expanation	O
as	O
well	O
as	O
some	O
links	O
to	O
some	O
proper	O
libraries	O
.	O

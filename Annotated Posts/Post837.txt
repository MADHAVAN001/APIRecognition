AppDomain.UnhandledException	O
is	O
an	O
event	O
,	O
not	O
a	O
global	O
exception	O
handler	O
.	O
This	O
means	O
,	O
by	O
the	O
time	O
it	O
is	O
raised	O
,	O
your	O
application	O
is	O
already	O
on	O
its	O
way	O
down	O
the	O
drain	O
,	O
and	O
there	O
is	O
nothing	O
you	O
can	O
do	O
about	O
it	O
,	O
except	O
for	O
doing	O
cleanup	O
and	O
error	O
logging	O
.	O
What	O
happened	O
behind	O
the	O
scenes	O
is	O
this	O
:	O
The	O
framework	O
detected	O
the	O
exception	O
,	O
walked	O
up	O
the	O
call	O
stack	O
to	O
the	O
very	O
top	O
,	O
found	O
no	O
handlers	O
that	O
would	O
recover	O
from	O
the	O
error	O
,	O
so	O
was	O
unable	O
to	O
determine	O
if	O
it	O
was	O
safe	O
to	O
continue	O
execution	O
.	O
So	O
,	O
it	O
started	O
the	O
shutdown	O
sequence	O
,	O
and	O
fired	O
up	O
this	O
event	O
as	O
a	O
courtesy	O
to	O
you	O
so	O
you	O
can	O
pay	O
your	O
respects	O
to	O
your	O
already-doomed	O
process	O
.	O
This	O
happens	O
when	O
an	O
exception	O
is	O
left	O
unhandled	O
in	O
the	O
main	O
thread	O
.	O
There	O
is	O
no	O
single-point	O
solution	O
to	O
this	O
kind	O
of	O
error	O
.	O
You	O
need	O
to	O
put	O
a	O
real	O
exception	O
handler	O
(	O
a	O
catch	O
block	O
)	O
upstream	O
of	O
all	O
places	O
where	O
this	O
error	O
occurs	O
and	O
forward	O
it	O
to	O
(	O
for	O
example	O
)	O
a	O
global	O
handler	O
method/class	O
that	O
will	O
determine	O
if	O
it	O
is	O
safe	O
to	O
simply	O
report	O
and	O
continue	O
,	O
based	O
on	O
exception	O
type	O
and/or	O
content	O
.	O
Edit	O
:	O
It	O
is	O
possible	O
to	O
disable	O
(	O
=hack	O
)	O
the	O
error-reporting	O
mechanism	O
built	O
into	O
Windows	O
so	O
the	O
mandatory	O
``	O
crash	O
and	O
burn	O
''	O
dialog	O
does	O
not	O
get	O
displayed	O
when	O
your	O
app	O
goes	O
down	O
.	O
However	O
,	O
this	O
becomes	O
effective	O
for	O
all	O
the	O
applications	O
in	O
the	O
system	O
,	O
not	O
just	O
your	O
own	O
.	O

If	O
you	O
need	O
to	O
populate	O
each	O
member	O
variable	O
by	O
hand	O
you	O
can	O
generalize	O
it	O
a	O
bit	O
as	O
far	O
as	O
the	O
primitives	O
are	O
concerned	O
by	O
using	O
FormatterServices	O
to	O
retrieve	O
in	O
order	O
the	O
list	O
of	O
variable	O
types	O
associated	O
with	O
an	O
object	O
.	O
I	O
've	O
had	O
to	O
do	O
this	O
in	O
a	O
project	O
where	O
I	O
had	O
a	O
lot	O
of	O
different	O
message	O
types	O
coming	O
off	O
the	O
stream	O
and	O
I	O
definitely	O
did	O
n't	O
want	O
to	O
write	O
the	O
serializer/deserializer	O
for	O
each	O
message	O
.	O
Here	O
's	O
the	O
code	O
I	O
used	O
to	O
generalize	O
the	O
deserialization	O
from	O
a	O
byte	O
[	O
]	O
.	O
public	O
virtual	O
bool	O
{	O
MemberInfo	O
[	O
]	O
members	O
=	O
)	O
;	O
object	O
[	O
]	O
values	O
=	O
;	O
int	O
j	O
=	O
0	O
;	O
for	O
(	O
int	O
i	O
=	O
0	O
;	O
i	O
members.Length	B-API
;	O
i++	O
)	O
{	O
string	O
[	O
]	O
var	O
=	O
;	O
switch	O
(	O
var	O
[	O
0	O
]	O
)	O
{	O
case	O
``	O
UInt32	O
''	O
:	O
values	B-API
[	I-API
i	I-API
]	I-API
=	I-API
+	I-API
(	I-API
message	B-API
[	I-API
j	I-API
+	I-API
1	I-API
]	I-API
16	I-API
)	I-API
+	I-API
(	I-API
message	B-API
[	I-API
j	I-API
+	I-API
2	I-API
]	I-API
8	I-API
)	I-API
+	I-API
message	B-API
[	I-API
j	I-API
+	I-API
3	I-API
]	I-API
)	I-API
;	I-API
j	I-API
+=	I-API
4	I-API
;	I-API
break	O
;	O
case	O
``	O
UInt16	O
''	O
:	O
values	B-API
[	I-API
i	I-API
]	I-API
=	I-API
+	I-API
message	B-API
[	I-API
j	I-API
+	I-API
1	I-API
]	I-API
)	I-API
;	I-API
j	I-API
+=	I-API
2	I-API
;	I-API
break	O
;	O
case	O
``	O
Byte	O
''	O
:	O
values	B-API
[	I-API
i	I-API
]	I-API
=	I-API
(	I-API
byte	I-API
)	I-API
message	B-API
[	I-API
j++	I-API
]	I-API
;	I-API
break	O
;	O
case	O
``	O
UInt32	O
[	O
]	O
''	O
:	O
if	O
(	O
values	B-API
[	I-API
i	I-API
]	I-API
!	I-API
=	I-API
null	I-API
)	I-API
{	I-API
int	I-API
len	I-API
=	I-API
values	B-API
[	I-API
i	I-API
]	I-API
)	I-API
.Length	I-API
;	O
byte	O
[	O
]	O
b	O
=	O
new	O
byte	O
[	O
len	O
*	O
4	O
]	O
;	O
;	O
,	O
(	O
UInt32	O
[	O
]	O
)	O
values	B-API
[	I-API
i	I-API
]	I-API
,	I-API
len	I-API
)	I-API
;	I-API
j	I-API
+=	I-API
len	I-API
*	I-API
4	I-API
;	I-API
}	I-API
break	I-API
;	I-API
case	I-API
``	I-API
Byte	B-API
[	I-API
]	I-API
''	O
:	O
if	O
(	O
values	B-API
[	I-API
i	I-API
]	I-API
!	I-API
=	I-API
null	I-API
)	I-API
{	O
int	O
len	O
=	O
values	B-API
[	I-API
i	I-API
]	I-API
)	I-API
.Length	I-API
;	I-API
(	I-API
values	B-API
[	I-API
i	I-API
]	I-API
)	I-API
,	I-API
0	I-API
,	I-API
len	I-API
)	I-API
;	I-API
j	I-API
+=	I-API
len	I-API
;	I-API
}	I-API
break	O
;	O
default	O
:	O
throw	O
new	O
;	O
}	O
}	O
;	O
return	O
true	O
;	O
(	O
byte	O
[	O
]	O
message	B-API
)	I-API
(	O
this.GetType	O
(	O
)	O
(	O
this	O
,	O
members	B-API
)	I-API
[	I-API
i	I-API
]	I-API
.ToString	I-API
(	I-API
)	I-API
.Split	I-API
(	I-API
new	I-API
char	I-API
[	I-API
]	I-API
{	I-API
'	I-API
'	I-API
}	I-API
)	I-API
UInt32	I-API
)	I-API
(	I-API
(	I-API
message	I-API
[	O
j	O
]	O
24	O
)	O
UInt16	O
)	O
(	O
(	O
message	O
[	O
j	O
]	O
8	O
)	O
(	B-API
(	I-API
UInt32	I-API
[	I-API
]	I-API
)	I-API
(	O
message	O
,	O
j	O
,	O
b	O
,	O
0	O
,	O
len	O
*	O
4	O
)	O
Array.Copy	B-API
(	I-API
Utilities.ByteArrayToUInt32Array	I-API
(	I-API
b	I-API
)	I-API
(	I-API
(	I-API
byte	I-API
[	I-API
]	I-API
)	I-API
(	O
message	O
,	O
j	O
,	O
(	O
byte	O
[	O
]	O
)	O
(	O
``	O
ByteExtractable	O
:	O
:SetMessageBytes	O
Unsupported	O
Type	O
:	O
``	O
+	O
var	O
[	O
1	O
]	O
+	O
``	O
is	O
of	O
type	O
``	O
+	O
var	O
[	O
0	O
]	O
)	O
(	O
this	O
,	O
members	O
,	O
values	O
)	O

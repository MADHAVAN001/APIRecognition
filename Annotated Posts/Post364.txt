If	O
you	O
need	O
to	O
populate	O
each	O
member	O
variable	O
by	O
hand	O
you	O
can	O
generalize	O
it	O
a	O
bit	O
as	O
far	O
as	O
the	O
primitives	O
are	O
concerned	O
by	O
using	O
FormatterServices	O
to	O
retrieve	O
in	O
order	O
the	O
list	O
of	O
variable	O
types	O
associated	O
with	O
an	O
object	O
.	O
I	O
've	O
had	O
to	O
do	O
this	O
in	O
a	O
project	O
where	O
I	O
had	O
a	O
lot	O
of	O
different	O
message	O
types	O
coming	O
off	O
the	O
stream	O
and	O
I	O
definitely	O
did	O
n't	O
want	O
to	O
write	O
the	O
serializer/deserializer	O
for	O
each	O
message	O
.	O
Here	O
's	O
the	O
code	O
I	O
used	O
to	O
generalize	O
the	O
deserialization	O
from	O
a	O
byte	O
[	O
]	O
.	O
public	B
virtual	B
bool	B
{	B
MemberInfo	B
[	I
]	I
members	B
=	B
)	B
;	I
object	B
[	I
]	I
values	B
=	B
;	B
int	B
j	B
=	B
0	B
;	I
for	B
(	B
int	I
i	B
=	B
0	B
;	I
i	B
members.Length	B
;	I
i++	B
)	I
{	B
string	B
[	I
]	I
var	B
=	B
;	B
switch	B
(	B
var	I
[	I
0	I
]	I
)	I
{	B
case	B
``	B
UInt32	I
''	I
:	I
values	B
[	I
i	I
]	I
=	B
+	B
(	B
message	I
[	I
j	I
+	B
1	B
]	I
16	B
)	I
+	B
(	B
message	I
[	I
j	I
+	B
2	B
]	I
8	B
)	I
+	B
message	B
[	I
j	I
+	B
3	B
]	I
)	I
;	I
j	B
+=	B
4	B
;	I
break	B
;	I
case	B
``	B
UInt16	I
''	I
:	I
values	B
[	I
i	I
]	I
=	B
+	B
message	B
[	I
j	I
+	B
1	B
]	I
)	I
;	I
j	B
+=	B
2	B
;	I
break	B
;	I
case	B
``	B
Byte	I
''	I
:	I
values	B
[	I
i	I
]	I
=	B
(	B
byte	I
)	I
message	I
[	I
j++	I
]	I
;	I
break	B
;	I
case	B
``	B
UInt32	I
[	I
]	I
''	I
:	I
if	B
(	B
values	I
[	I
i	I
]	I
!	B
=	I
null	B
)	I
{	B
int	B
len	B
=	B
values	B
[	I
i	I
]	I
)	I
.Length	I
;	I
byte	B
[	I
]	I
b	B
=	B
new	B
byte	B
[	I
len	I
*	B
4	B
]	I
;	I
;	B
,	B
(	B
UInt32	I
[	I
]	I
)	I
values	I
[	I
i	I
]	I
,	I
len	B
)	I
;	I
j	B
+=	B
len	B
*	B
4	B
;	I
}	B
break	B
;	I
case	B
``	B
Byte	I
[	I
]	I
''	I
:	I
if	B
(	B
values	I
[	I
i	I
]	I
!	B
=	I
null	B
)	I
{	B
int	B
len	B
=	B
values	B
[	I
i	I
]	I
)	I
.Length	I
;	I
(	B
values	I
[	I
i	I
]	I
)	I
,	I
0	B
,	I
len	B
)	I
;	I
j	B
+=	B
len	B
;	I
}	B
break	B
;	I
default	B
:	I
throw	B
new	B
;	B
}	B
}	B
;	B
return	B
true	B
;	I
(	O
byte	O
[	O
]	O
message	O
)	O
(	O
this.GetType	O
(	O
)	O
(	O
this	O
,	O
members	O
)	O
[	O
i	O
]	O
.ToString	O
(	O
)	O
.Split	O
(	O
new	O
char	O
[	O
]	O
{	O
'	O
'	O
}	O
)	O
UInt32	O
)	O
(	O
(	O
message	O
[	O
j	O
]	O
24	O
)	O
UInt16	O
)	O
(	O
(	O
message	O
[	O
j	O
]	O
8	O
)	O
(	B
(	I
UInt32	I
[	I
]	I
)	I
(	O
message	O
,	O
j	O
,	O
b	O
,	O
0	O
,	O
len	O
*	O
4	O
)	O
Array.Copy	B
(	I
Utilities.ByteArrayToUInt32Array	I
(	I
b	I
)	I
(	B
(	I
byte	I
[	I
]	I
)	I
(	O
message	O
,	O
j	O
,	O
(	O
byte	O
[	O
]	O
)	O
(	O
``	O
ByteExtractable	O
:	O
:SetMessageBytes	O
Unsupported	O
Type	O
:	O
``	O
+	O
var	O
[	O
1	O
]	O
+	O
``	O
is	O
of	O
type	O
``	O
+	O
var	O
[	O
0	O
]	O
)	O
(	O
this	O
,	O
members	O
,	O
values	O
)	O

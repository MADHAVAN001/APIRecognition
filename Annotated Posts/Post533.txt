I	O
wound	O
up	O
just	O
implementing	O
the	O
translation	O
manually	O
.	O
The	O
code	O
's	O
not	O
too	O
bad	O
,	O
but	O
it	O
did	O
leave	O
me	O
wishing	O
that	O
they	O
provided	O
support	O
for	O
it	O
directly	O
.	O
I	O
could	O
see	O
such	O
a	O
method	O
being	O
useful	O
in	O
a	O
lot	O
of	O
different	O
circumstances	O
.	O
I	O
guess	O
that	O
's	O
why	O
they	O
added	O
extension	O
methods	O
:	O
)	O
In	O
pseudocode	O
:	O
//	O
Recompute	O
the	O
image	O
scaling	O
the	O
zoom	O
mode	O
uses	O
to	O
fit	O
the	O
image	O
on	O
screen	O
imageScale	O
:	O
:=	O
min	B-API
(	I-API
pictureBox.width	I-API
/	I-API
image.width	I-API
,	I-API
pictureBox.height	I-API
/	I-API
image.height	I-API
)	I-API
scaledWidth	O
:	O
:=	O
image.width	B-API
*	O
imageScale	B-API
scaledHeight	O
:	O
:=	O
image.height	B-API
*	O
imageScale	B-API
//	O
Compute	O
the	O
offset	O
of	O
the	O
image	O
to	O
center	O
it	O
in	O
the	O
picture	O
box	O
imageX	O
:	O
:=	O
(	B-API
pictureBox.width	I-API
-	I-API
scaledWidth	I-API
)	I-API
/	O
2	O
imageY	O
:	O
:=	O
(	B-API
pictureBox.height	I-API
-	I-API
scaledHeight	I-API
)	I-API
/	O
2	O
//	O
Test	O
the	O
coordinate	O
in	O
the	O
picture	O
box	O
against	O
the	O
image	O
bounds	O
if	O
pos.x	O
imageX	O
or	O
imageX	O
+	O
scaledWidth	O
pos.x	O
then	O
return	O
null	O
if	O
pos.y	O
imageY	O
or	O
imageY	O
+	O
scaledHeight	O
pos.y	O
then	O
return	O
null	O
//	O
Compute	O
the	O
normalized	O
(	O
0..1	O
)	O
coordinates	O
in	O
image	O
space	O
u	O
:	O
:=	O
(	B-API
pos.x	I-API
-	I-API
imageX	I-API
)	I-API
/	O
imageScale	B-API
v	O
:	O
:=	O
(	B-API
pos.y	I-API
-	I-API
imageY	I-API
)	I-API
/	O
imageScale	B-API
return	B-API
(	I-API
u	I-API
,	I-API
v	I-API
)	I-API
To	O
get	O
the	O
pixel	O
position	O
in	O
the	O
image	O
,	O
you	O
'd	O
just	O
multiply	O
by	O
the	O
actual	O
image	O
pixel	O
dimensions	O
,	O
but	O
the	O
normalized	O
coordinates	O
allow	O
you	O
to	O
address	O
the	O
original	O
responder	O
's	O
point	O
about	O
resolving	O
ambiguity	O
on	O
a	O
case-by-case	O
basis	O
.	O

Hmm	O
,	O
ok	O
.	O
I	O
'd	O
suggest	O
code	O
like	O
this	O
,	O
then	O
:	O
typedef	B
struct	B
{	B
int	B
type	B
;	I
int	B
result	B
;	I
}	I
DialogData	B
;	I
static	I
{	B
DialogData	B
*dialog_data	B
=	B
user_data	B
;	I
GtkWidget	B
*dialog	B
;	I
if	B
(	B
dialog_data-type	I
MB_YESNO	B
)	I
dialog	B
=	B
;	B
else	B
dialog	B
=	B
;	B
//	B
Set	B
title	B
,	I
etc	B
.	I
dialog_data-result	B
=	B
;	B
;	B
//	B
Quits	B
the	B
main	B
loop	B
run	B
in	B
return	B
FALSE	B
;	I
}	I
int	I
{	B
DialogData	B
dialog_data	B
;	I
dialog_data.type	B
=	B
type	B
;	I
;	B
;	B
//	B
Do	B
stuff	B
based	B
on	B
(	O
gpointer	O
user_data	O
)	O
gtk_message_dialog_new	B
(	I
...	I
)	I
gtk_message_dialog_new	B
(	I
...	I
)	I
gtk_dialog_run	B
(	I
...	I
)	I
gtk_main_quit	B
(	I
)	I
MessageBox	B
(	I
)	I
MessageBox	B
(	I
...	I
)	I
(	O
display_dialog	O
,	O
dialog_data	O
)	O
gtk_main	B
(	I
)	I
The	O
struct	O
is	O
because	O
you	O
need	O
to	O
pass	O
around	O
a	O
couple	O
pieces	O
of	O
data	O
.	O
The	O
gtk_idle_add	B
(	I
)	I
call	O
adds	O
a	O
method	O
to	O
be	O
run	O
when	O
the	O
main	O
loop	O
is	O
running	O
and	O
idle	O
,	O
and	O
the	O
return	O
value	O
from	O
the	O
display_dialog	B
(	I
)	I
call	O
means	O
that	O
it	O
's	O
only	O
run	O
once	O
.	O
After	O
we	O
get	O
the	O
result	O
from	O
the	O
dialog	O
,	O
we	O
quit	O
the	O
main	O
loop	O
.	O
That	O
'll	O
cause	O
the	O
gtk_main	B
(	I
)	I
in	O
your	O
main	O
MessageBox	B
(	I
)	I
method	O
to	O
return	O
,	O
and	O
you	O
'll	O
be	O
able	O
to	O
access	O
the	O
result	O
from	O
there	O
.	O
Hope	O
this	O
helps	O
!	O

Hmm	O
,	O
ok	O
.	O
I	O
'd	O
suggest	O
code	O
like	O
this	O
,	O
then	O
:	O
typedef	O
struct	O
{	O
int	O
type	O
;	O
int	O
result	O
;	O
}	O
DialogData	O
;	O
static	O
{	O
DialogData	O
*dialog_data	O
=	O
user_data	O
;	O
GtkWidget	O
*dialog	O
;	O
if	O
(	O
dialog_data-type	O
MB_YESNO	O
)	O
dialog	O
=	O
;	O
else	O
dialog	O
=	O
;	O
//	O
Set	O
title	O
,	O
etc	O
.	O
dialog_data-result	O
=	O
;	O
;	O
//	O
Quits	O
the	O
main	O
loop	O
run	O
in	O
return	O
FALSE	O
;	O
}	O
int	O
{	O
DialogData	O
dialog_data	O
;	O
dialog_data.type	O
=	O
type	O
;	O
;	O
;	O
//	O
Do	O
stuff	O
based	O
on	O
(	O
gpointer	O
user_data	O
)	O
gtk_message_dialog_new	B-API
(	I-API
...	I-API
)	I-API
gtk_message_dialog_new	B-API
(	I-API
...	I-API
)	I-API
gtk_dialog_run	B-API
(	I-API
...	I-API
)	I-API
gtk_main_quit	B-API
(	I-API
)	I-API
MessageBox	B-API
(	I-API
)	I-API
MessageBox	B-API
(	I-API
...	I-API
)	I-API
(	O
display_dialog	O
,	O
dialog_data	O
)	O
gtk_main	B-API
(	I-API
)	I-API
The	O
struct	O
is	O
because	O
you	O
need	O
to	O
pass	O
around	O
a	O
couple	O
pieces	O
of	O
data	O
.	O
The	O
gtk_idle_add	B-API
(	I-API
)	I-API
call	O
adds	O
a	O
method	O
to	O
be	O
run	O
when	O
the	O
main	O
loop	O
is	O
running	O
and	O
idle	O
,	O
and	O
the	O
return	O
value	O
from	O
the	O
display_dialog	B-API
(	I-API
)	I-API
call	O
means	O
that	O
it	O
's	O
only	O
run	O
once	O
.	O
After	O
we	O
get	O
the	O
result	O
from	O
the	O
dialog	O
,	O
we	O
quit	O
the	O
main	O
loop	O
.	O
That	O
'll	O
cause	O
the	O
gtk_main	B-API
(	I-API
)	I-API
in	O
your	O
main	O
MessageBox	B-API
(	I-API
)	I-API
method	O
to	O
return	O
,	O
and	O
you	O
'll	O
be	O
able	O
to	O
access	O
the	O
result	O
from	O
there	O
.	O
Hope	O
this	O
helps	O
!	O

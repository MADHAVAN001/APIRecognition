So	O
I	O
find	O
myself	O
porting	O
a	O
game	O
,	O
that	O
was	O
originally	O
written	O
for	O
the	O
Win32	B
API	I
,	O
to	O
Linux	O
(	O
well	O
,	O
porting	O
the	O
OS	O
X	O
port	O
of	O
the	O
Win32	O
port	O
to	O
Linux	O
)	O
.	O
I	O
have	O
implemented	O
by	O
giving	O
the	O
uSeconds	O
since	O
the	O
process	O
start	O
up	O
:	O
BOOL	O
QueryPerformanceCounter	O
(	O
LARGE_INTEGER*	O
performanceCount	O
)	O
{	O
gettimeofday	B
(	I
currentTimeVal	I
,	I
NULL	I
)	I
;	O
performanceCount-QuadPart	O
=	O
(	O
currentTimeVal.tv_sec	O
-	O
startTimeVal.tv_sec	O
)	O
;	O
performanceCount-QuadPart	O
*=	O
(	O
1000	O
*	O
1000	O
)	O
;	O
performanceCount-QuadPart	O
+=	O
(	O
currentTimeVal.tv_usec	O
-	O
startTimeVal.tv_usec	O
)	O
;	O
return	O
true	O
;	O
}	O
This	O
,	O
coupled	O
with	O
QueryPerformanceFrequency	B
(	I
)	I
giving	O
a	O
constant	O
1000000	O
as	O
the	O
frequency	O
,	O
works	O
well	O
on	O
my	O
machine	O
,	O
giving	O
me	O
a	O
64	O
bit	O
variable	O
that	O
contains	O
since	O
the	O
program	O
's	O
start	O
up	O
.	O
So	O
is	O
this	O
portable	O
?	O
I	O
do	O
n't	O
want	O
to	O
discover	O
it	O
works	O
differently	O
if	O
the	O
kernel	O
was	O
compiled	O
in	O
a	O
certain	O
way	O
or	O
anything	O
like	O
that	O
.	O
I	O
am	O
fine	O
with	O
it	O
being	O
non-portable	O
to	O
something	O
other	O
than	O
Linux	O
,	O
however	O
.	O

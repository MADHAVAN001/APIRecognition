High	O
Resolution	O
,	O
Low	O
Overhead	O
Timing	O
for	O
Intel	O
Processors	O
If	O
you	O
're	O
on	O
Intel	O
hardware	O
,	O
here	O
's	O
how	O
to	O
read	O
the	O
CPU	O
real-time	O
instruction	O
counter	O
.	O
It	O
will	O
tell	O
you	O
the	O
number	O
of	O
CPU	O
cycles	O
executed	O
since	O
the	O
processor	O
was	O
booted	O
.	O
This	O
is	O
probably	O
the	O
finest-grained	O
counter	O
you	O
can	O
get	O
for	O
performance	O
measurement	O
.	O
Note	O
that	O
this	O
is	O
the	O
number	O
of	O
CPU	O
cycles	O
.	O
On	O
linux	O
you	O
can	O
get	O
the	O
CPU	O
speed	O
from	O
/proc/cpuinfo	O
and	O
divide	O
to	O
get	O
the	O
number	O
of	O
seconds	O
.	O
Converting	O
this	O
to	O
a	O
double	O
is	O
quite	O
handy	O
.	O
When	O
I	O
run	O
this	O
on	O
my	O
box	O
,	O
I	O
get	O
11867927879484732	O
11867927879692217	O
it	O
took	O
this	O
long	O
to	O
call	O
printf	O
:	O
207485	O
Here	O
's	O
the	O
Intel	O
developer	O
's	O
guide	O
that	O
gives	O
tons	O
of	O
detail	O
.	O
#	O
include	O
stdio.h	O
#	O
include	O
stdint.h	O
inline	O
uint64_t	O
rdtsc	O
(	O
)	O
{	O
uint32_t	O
lo	O
,	O
hi	O
;	O
__asm__	O
__volatile__	O
(	O
``	O
xorl	O
%	O
%	O
eax	O
,	O
%	O
%	O
eax\n	O
''	O
``	O
cpuid\n	O
''	O
``	O
rdtsc\n	O
''	O
:	O
``	O
=a	O
''	O
(	O
lo	O
)	O
,	O
``	O
=d	O
''	O
(	O
hi	O
)	O
:	O
:	O
``	O
%	O
ebx	O
''	O
,	O
``	O
%	O
ecx	O
''	O
)	O
;	O
return	O
(	O
uint64_t	O
)	O
hi	O
32	O
|	O
lo	O
;	O
}	O
main	O
(	O
)	O
{	O
unsigned	O
long	O
long	O
x	O
;	O
unsigned	O
long	O
long	O
y	O
;	O
x	O
=	O
rdtsc	B
(	I
)	I
;	O
printf	B
(	I
``	I
%	I
lld\n	I
''	I
,	I
x	I
)	I
;	O
y	O
=	O
rdtsc	B
(	I
)	I
;	O
printf	N
(	I
``	I
%	I
lld\n	I
''	I
,	I
y	I
)	I
;	O
printf	B
(	I
``	I
it	I
took	I
this	I
long	I
to	I
call	I
printf	I
:	I
%	I
lld\n	I
''	I
,	I
y-x	I
)	I
;	O
}	O

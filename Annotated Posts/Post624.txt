Static	B-API
methods	O
can	O
not	O
be	O
inherited	O
or	O
overridden	O
,	O
and	O
that	O
is	O
why	O
they	O
ca	O
n't	O
be	O
abstract	O
.	O
Since	O
static	B-API
methods	O
are	O
defined	O
on	O
the	O
type	O
,	O
not	O
the	O
instance	O
,	O
of	O
a	O
class	O
,	O
they	O
must	O
be	O
called	O
explicitly	O
on	O
that	O
type	O
.	O
So	O
when	O
you	O
want	O
to	O
call	O
a	O
method	O
on	O
a	O
child	O
class	O
,	O
you	O
need	O
to	O
use	O
its	O
name	O
to	O
call	O
it	O
.	O
This	O
makes	O
inheritance	O
irrelevant	O
.	O
Assume	O
you	O
could	O
,	O
for	O
a	O
moment	O
,	O
inherit	O
static	B-API
methods	O
.	O
Imagine	O
this	O
scenario	O
:	O
public	O
static	B-API
class	O
Base	O
{	O
public	O
static	B-API
virtual	I-API
int	I-API
{	I-API
return	I-API
5	I-API
;	I-API
}	I-API
}	O
public	O
static	B-API
class	I-API
Child1	I-API
:	I-API
Base	I-API
{	O
public	O
static	B-API
override	I-API
int	I-API
{	O
return	O
1	O
;	O
}	O
}	O
public	O
static	B-API
class	I-API
Child2	I-API
:	I-API
Base	I-API
{	O
public	O
static	B-API
override	I-API
int	I-API
{	O
return	O
2	O
;	O
GetNumber	B-API
(	I-API
)	I-API
GetNumber	B-API
(	I-API
)	I-API
GetNumber	B-API
(	I-API
)	I-API
If	O
you	O
call	O
Base.GetNumber	B-API
(	I-API
)	I-API
,	O
which	O
method	O
would	O
be	O
called	O
?	O
Which	O
value	O
returned	O
?	O
Its	O
pretty	O
easy	O
to	O
see	O
that	O
without	O
creating	O
instances	O
of	O
objects	O
,	O
inheritance	O
is	O
rather	O
hard	O
.	O
Abstract	O
methods	O
without	O
inheritance	O
are	O
just	O
methods	O
that	O
do	O
n't	O
have	O
a	O
body	O
,	O
so	O
ca	O
n't	O
be	O
called	O
.	O

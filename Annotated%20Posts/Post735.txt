Brian	O
gives	O
a	O
nice	O
solution	O
for	O
converting	O
it	O
to	O
a	O
strongly	O
typed	O
collection	O
.	O
Most	O
of	O
the	O
CSV	O
parsing	O
methods	O
given	O
do	O
n't	O
take	O
into	O
account	O
escaping	O
fields	O
or	O
some	O
of	O
the	O
other	O
subtleties	O
of	O
CSV	O
files	O
(	O
like	O
trimming	O
fields	O
)	O
.	O
Here	O
is	O
the	O
code	O
I	O
personally	O
use	O
.	O
It	O
's	O
a	O
bit	O
rough	O
around	O
the	O
edges	O
and	O
has	O
pretty	O
much	O
no	O
error	O
reporting	O
.	O
public	O
static	B
IListIListstring	O
{	O
IListIListstring	O
records	O
=	O
new	O
;	O
StringReader	B
stringReader	I
=	I
new	I
;	O
bool	B
inQoutedString	I
=	I
false	I
;	I
IListstring	B
record	B
=	B
new	I
;	O
StringBuilder	B
fieldBuilder	I
=	I
new	I
;	O
while	O
!	O
=	O
-1	O
)	O
{	O
char	O
readChar	O
=	O
;	O
if	O
(	O
readChar	O
==	O
'\n	O
'	O
||	O
(	O
readChar	O
==	O
'\r	O
'	O
==	O
'\n	O
'	O
)	O
)	O
{	O
//	O
If	O
it	O
's	O
a	O
\r\n	O
combo	O
consume	O
the	O
\n	O
part	O
and	O
throw	O
it	O
away	O
.	O
if	O
(	O
readChar	O
==	O
'\r	O
'	O
)	O
{	O
;	O
}	O
if	O
(	O
inQoutedString	O
)	O
{	O
if	O
(	O
readChar	O
==	O
'\r	O
'	O
)	O
{	O
;	O
}	O
;	O
}	O
else	O
{	O
)	O
;	O
fieldBuilder	B
=	I
new	I
;	O
;	O
record	O
=	O
new	O
;	O
inQoutedString	O
=	O
false	O
;	O
}	O
}	O
else	O
if	O
(	O
fieldBuilder.Length	O
==	O
0	O
!	O
inQoutedString	O
)	O
{	O
if	O
)	O
{	O
//	O
Ignore	O
leading	O
whitespaCe	O
}	O
else	O
if	O
(	O
readChar	O
==	O
'	O
''	O
'	O
)	O
{	O
inQoutedString	O
=	O
true	O
;	O
}	O
else	O
if	O
(	O
readChar	O
==	O
'	O
,	O
'	O
)	O
{	O
)	O
;	O
fieldBuilder	O
=	O
new	O
;	O
}	O
else	O
{	O
;	O
}	O
}	O
else	O
if	O
(	O
readChaO	O
==	O
'	O
,	O
'	O
)	O
{	O
if	O
(	O
inQoutedString	O
)	O
{	O
;	O
}	O
else	O
{	O
)	O
;	O
fieldBuilder	O
=	O
new	O
;	O
}	O
}	O
else	O
if	O
(	O
readChar	O
==	O
'	O
''	O
'	O
)	O
{	O
if	O
(	O
inQoutedString	O
)	O
{	O
if	O
==	O
'	O
''	O
'	O
)	O
{	O
;	O
;	O
}	O
else	O
{	O
inQoutedString	O
=	O
false	O
;	O
}	O
}	O
else	O
{	O
;	O
}	O
}	O
else	O
{	O
;	O
}	O
}	O
)	O
;	O
;	O
return	O
(	O
string	B
content	I
)	O
ListIListstring	B
(	I
)	I
StringReader	B
(	I
content	I
)	I
Liststring	B
(	I
)	I
StringBuilder	B
(	I
)	I
(	O
stringReader.Peek	B
(	I
)	I
(	O
char	O
)	O
stringReader.Read	B
(	I
)	I
stringReader.Peek	B
(	I
)	I
stringReader.Read	B
(	I
)	I
fieldBuilder.Append	B
(	I
'\r	I
'	I
)	I
fieldBuilder.Append	B
(	I
'\n	I
'	I
)	I
record.Add	B
(	I
fieldBuilder.ToString	B
(	I
)	I
.TrimEnd	I
(	I
)	I
StringBuilder	B
(	I
)	I
records.Add	O
(	O
record	O
)	O
Liststring	O
(	O
)	O
(	O
char.IsWhiteSpace	B
(	I
readChar	I
)	I
record.Add	O
(	O
fieldBuilder.ToString	B
(	I
)	I
.TrimEnd	I
(	I
)	I
StringBuilder	B
(	I
)	I
fieldBuilder.Append	B
(	I
readChar	I
)	I
fieldBuilder.Append	B
(	I
'	I
,	I
'	I
)	I
record.Add	B
(	I
fieldBuilder.ToString	I
(	I
)	I
.TrimEnd	I
(	I
)	I
StringBuilder	B
(	I
)	I
(	O
stringReader.Peek	B
(	I
)	I
stringReader.Read	B
(	I
)	I
fieldBuilder.Append	B
(	I
'	I
''	I
'	I
)	I
fieldBuilder.Append	B
(	I
readChar	I
)	I
fieldBuilder.Append	B
(	I
readChar	I
)	I
record.Add	B
(	I
fieldBuilder.ToString	B
(	I
)	I
.TrimEnd	I
(	I
)	I
records.Add	B
(	I
record	I
)	I
Note	O
that	O
this	O
does	O
n't	O
handle	O
the	O
edge	O
case	O
of	O
fields	O
not	O
being	O
deliminated	O
by	O
double	O
quotes	O
,	O
but	O
meerley	O
having	O
a	O
quoted	O
string	O
inside	O
of	O
it	O
.	O
See	O
this	O
post	O
for	O
a	O
bit	O
of	O
a	O
better	O
expanation	O
as	O
well	O
as	O
some	O
links	O
to	O
some	O
proper	O
libraries	O
.	O

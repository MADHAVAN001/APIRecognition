Both	O
cases	O
will	O
execute	O
the	O
function	O
,	O
the	O
only	O
real	O
difference	O
is	O
what	O
the	O
return	O
value	O
of	O
the	O
expression	O
may	O
be	O
,	O
and	O
what	O
the	O
value	O
of	O
``	O
this	O
''	O
will	O
be	O
inside	O
the	O
function	O
.	O
Basically	O
behaviour	O
of	O
new	O
Is	O
effectively	O
equivalent	O
to	O
var	B
tempObject	O
=	O
{	O
}	O
;	O
var	B
result	O
=	O
;	O
if	B
(	I
result	I
is	I
not	I
an	I
object	I
)	I
result	O
=	O
expression.call	B
(	I
tempObject	I
)	I
Although	O
of	O
course	O
and	O
result	O
are	O
transient	O
values	O
you	O
can	O
never	O
see	O
(	O
they	O
're	O
implementation	O
details	O
in	O
the	O
interpreter	O
)	O
,	O
and	O
there	O
is	O
no	O
JS	B
mechanism	O
to	O
do	O
the	O
``	O
is	O
not	O
an	O
object	O
''	O
check	O
.	O
Broadly	O
speaking	O
the	O
``	O
new	O
function	B
(	I
)	I
{	O
..	O
}	O
''	O
method	O
will	O
be	O
slower	O
due	O
to	O
the	O
need	O
to	O
create	O
the	O
this	O
object	O
for	O
the	O
constructor	O
.	O
That	O
said	O
this	O
should	O
be	O
not	O
be	O
a	O
real	O
difference	O
as	O
object	O
allocation	O
is	O
not	O
slow	O
,	O
and	O
you	O
should	O
n't	O
be	O
using	O
such	O
code	O
in	O
hot	O
code	O
(	O
due	O
to	O
the	O
cost	O
of	O
creating	O
the	O
function	O
object	O
and	O
associated	O
closure	O
)	O
.	O
Edit	O
:	O
one	O
thing	O
i	O
realised	O
that	O
i	O
missed	O
from	O
this	O
is	O
that	O
the	O
tempObject	O
will	O
get	O
s	O
prototype	O
,	O
eg	O
.	O
(	O
before	O
the	O
)	O
tempObject.__proto__	B
=	O
